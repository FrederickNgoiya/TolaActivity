{"version":3,"file":"iptt_report-1700a86bf94b358d44b9.js","sources":["webpack:///./js/pages/iptt_report/components/main.js","webpack:///./js/pages/iptt_report/components/filterForm.js","webpack:///./js/pages/iptt_report/fixtures.js","webpack:///./js/formUtils.js","webpack:///./js/level_utils.js","webpack:///./js/pages/iptt_report/models.js","webpack:///./js/pages/iptt_report/components/headerComponents.js","webpack:///./js/pages/iptt_report/components/reportTable.js","webpack:///./js/pages/iptt_report/index.js","webpack:///./js/pages/iptt_report/components/buttons.js","webpack:///./js/pages/iptt_report/components/selectWidgets.js"],"sourcesContent":["import React from 'react';\nimport { inject, observer } from 'mobx-react';\nimport IPTTTable from './reportTable';\nimport IPTTFilterForm from './filterForm';\nimport { PinButton, ExcelButton, ClearButton } from './buttons';\n\n\nconst IPTTHeader = inject('labels', 'rootStore')(\n    observer(({ labels, rootStore }) => {\n        return <div className=\"page-subheader\">\n                    <div id=\"id_span_iptt_date_range\" className=\"subheader__title\">\n                        <h2 className=\"pt-3 text-title-case\">{ labels.reportTitle }</h2>\n                        <h4 className=\"pb-3\">{ (rootStore.startPeriodLabel && rootStore.endPeriodLabel)\n                                               ? rootStore.startPeriodLabel + \" - \" + rootStore.endPeriodLabel\n                                               : \"\" }</h4>\n                    </div>\n                    <div className=\"subheader__actions\">\n                        <PinButton />\n                        <ExcelButton />\n                    </div>\n                </div>\n    })\n);\n\n\nconst IPTTSidebar = inject('labels')(({ labels }) => {\n    return <div className=\"sidebar_wrapper\">\n                <div className=\"collapse width show\" id=\"sidebar\">\n                  <IPTTFilterForm />\n                  <div id=\"filter-bottom\"\n                       className=\"d-flex justify-content-between no-gutters p-3\">\n                    <ClearButton />\n                  </div>\n                </div>\n                <div className=\"sidebar-toggle\">\n                  <a href=\"#\" data-target=\"#sidebar\" data-toggle=\"collapse\"\n                        title={ labels.sidebarToggle }>\n                    <i className=\"fa fa-chevron-left\"></i>\n                  </a>\n                </div>\n            </div>;\n});\n\n\nconst IPTTReport = () => {\n    return <main className=\"iptt_table_wrapper\">\n                <div id=\"id_div_top_iptt_report\">\n                    <IPTTHeader />\n                    <IPTTTable />\n                </div>\n            </main>;\n                \n}\n\nexport class IPTTReportApp extends React.Component {\n    render() {\n        return <React.Fragment>\n            <IPTTSidebar />\n            <IPTTReport />\n        </React.Fragment>\n    }\n}","import React from 'react';\nimport { inject, observer } from 'mobx-react';\nimport { computed } from 'mobx';\nimport Select from 'react-select';\nimport { CheckboxGroupHeading } from 'react-multiselect-checkboxes/lib/CheckboxGroup';\nimport ReactMultiSelectCheckboxes from 'react-multiselect-checkboxes';\nimport { IPTTMultiselectCheckboxWrapper, IPTTSelect, DateSelect, IPTTSelectWrapper } from './selectWidgets';\nimport { uniqueId } from '../../../formUtils';\n\n/**\n * input-ready filtering single-select for Programs available to user in IPTT Report\n * extends IPTTSelect in components/selectWidgets\n */\n@inject('labels', 'rootStore')\n@observer\nclass ProgramSelect extends IPTTSelect {\n    get label() { return this.props.labels.programSelect;}\n    get selectOptions() {\n        return {\n            options: this.props.rootStore.programOptions,\n            value: this.props.rootStore.selectedProgramOption,\n            onChange: selected => {this.props.rootStore.setProgramId(selected.value)}\n        };\n    }\n}\n\n/**\n * input-ready filtering single-select for Frequencies available for selected program in IPTT Report\n * extends IPTTSelect in components/selectWidgets\n */\n@inject('labels', 'rootStore')\n@observer\nclass PeriodSelect extends IPTTSelect {\n    get label() { return this.props.rootStore.isTVA ? this.props.labels.periodSelect.tva\n                                                    : this.props.labels.periodSelect.timeperiods; }\n    get selectOptions() {\n        return {\n            options: this.props.rootStore.frequencyOptions,\n            value: this.props.rootStore.selectedFrequencyOption,\n            onChange: selected => {this.props.rootStore.setFrequencyId(selected.value)}\n        };\n    }\n}\n\n/**\n * non input-ready dropdown for periods available for Start of IPTT Report select\n * composes DateSelect in components/selectWidgets\n */\nconst StartDateSelect = inject('labels', 'rootStore')(\n    observer(({labels, rootStore}) => {\n        const selectHandler = (e) => { rootStore.setStartPeriod(e.target.value); }\n        return <DateSelect label={ labels.startPeriod }\n                           value={ rootStore.startPeriod }\n                           onChange={ selectHandler } />\n    })\n);\n\n/**\n * non input-ready dropdown for periods available for End of IPTT Report select\n * composes DateSelect in components/selectWidgets\n */\nconst EndDateSelect = inject('labels', 'rootStore')(\n    observer(({labels, rootStore}) => {\n        const selectHandler = (e) => { rootStore.setEndPeriod(e.target.value); }\n        return <DateSelect label={ labels.endPeriod }\n                           value={ rootStore.endPeriod }\n                           onChange={ selectHandler } />\n    })\n);\n\n/**\n * Show All radio / Most Recent radio / number of Most Recent periods input combo component\n * For selecting start and end of IPTT report\n * controlled component - logic to update date selects in rootStore model (../models)\n */\n@inject('labels', 'rootStore')\n@observer\nclass TimeFrameRadio extends React.Component {\n    checkMostRecent = () => {\n        //default value of 2 in case of clicking \"most recent\" radio box - default behavior\n        this.props.rootStore.setMostRecent(2);\n    }\n    updateMostRecentCount = (e) => {\n        this.props.rootStore.setMostRecent(e.target.value);\n    }\n    render() {\n        return <div className=\"form-row mb-3\">\n                    <div className=\"col-sm-4\">\n                        <div className=\"form-check form-check-inline pt-1\">\n                            <span className=\"form-check-input\">\n                                <input type=\"radio\"\n                                       checked={ this.props.rootStore.showAll }\n                                       disabled={ !this.props.rootStore.timeframeEnabled }\n                                       onChange={ this.props.rootStore.setShowAll }\n                                       />\n                            </span>\n                            <label className=\"form-check-label\">\n                                { this.props.labels.showAll }\n                            </label>\n                        </div>\n                    </div>\n                    <div className=\"col-sm-4 p-0\">\n                        <div className=\"form-check form-check-inline pt-1\">\n                            <span className=\"form-check-input\">\n                                <input type=\"radio\"\n                                       checked={ this.props.rootStore.mostRecent !== null }\n                                       disabled={ !this.props.rootStore.timeframeEnabled }\n                                       onChange={ this.checkMostRecent }\n                                       />\n                            </span>\n                            <label className=\"form-check-label\">\n                                { this.props.labels.mostRecent}\n                            </label>\n                        </div>\n                    </div>\n                    <div className=\"col-sm-4\">\n                        <input type=\"number\" className=\"form-control\"\n                               value={ this.props.rootStore.mostRecent || ''}\n                               disabled={ !this.props.rootStore.timeframeEnabled }\n                               onChange={ this.updateMostRecentCount }\n                               />\n                    </div>\n               </div>;\n    }\n}\n\n/**\n * single select with non dynamic options (dynamic labeling based on program's name for tier 2)\n * selects \"grouping\" or \"chaining\" based display of indicators in report and filter dropdowns\n * composes IPTTSelectWrapper from components/selectWidgets\n */\n@inject('labels', 'rootStore')\n@observer\nclass GroupingSelect extends React.Component {\n    _id = \"grouping-select1\"\n    onChange = (e) => {\n        this.props.rootStore.setLevelGrouping(e.target.value);\n    }\n    \n    render() {\n        return (\n            <IPTTSelectWrapper id={ this._id } label={ this.props.labels.levelGrouping.label }>\n                <select className=\"form-control\"\n                        id={ this._id }\n                        value={ (this.props.rootStore.levelGrouping ? 1 : 0) }\n                        onChange={ this.onChange }>\n                        <option value=\"0\">{ this.props.rootStore.selectedProgram.resultChainFilter }</option>\n                        <option value=\"1\">{ this.props.labels.levelGrouping.group }</option>\n                </select>\n            </IPTTSelectWrapper>\n        );\n    }\n}\n\n/**\n * input-ready multi-select checkbox widget for filtering IPTT report by level\n * contains both \"grouping\" and \"chaining\" filtering options, displayed as two optgroups\n * labeling for second optgroup is based on Program's definition of tier 2 (stored in rootStore.selectedProgram)\n * extends IPTTMultiselectCheckboxWrapper (with helper functions for styling/labeling) in components/selectWidgets\n */\n@inject('labels', 'rootStore')\n@observer\nclass LevelSelect extends IPTTMultiselectCheckboxWrapper {\n    get options() {\n        let tiers = this.props.rootStore.selectedProgram.reportLevelTiers;\n        let chains = this.props.rootStore.selectedProgram.reportLevelChains;\n        if (tiers.length == 0 && chains.length == 0) {\n            return [];\n        }\n        return [\n            {label: '',\n             options: tiers},\n             {label: this.props.rootStore.selectedProgram.resultChainHeader,\n             options: chains}\n        ];\n    }\n    get value() {\n        if (this.props.rootStore.levelFilters && this.props.rootStore.levelFilters.length > 0) {\n            return this.props.rootStore.levelFilters;\n        } else if (this.props.rootStore.tierFilters && this.props.rootStore.tierFilters.length > 0) {\n            return this.props.rootStore.tierFilters;\n        } else {\n            return [];\n        }\n    }\n    get label() {\n        return this.props.labels.levelSelect;\n    }\n    \n    onChange = (selected) => {\n        let levelSelects = selected.filter(option => option.filterType == 'level');\n        let tierSelects = selected.filter(option => option.filterType == 'tier');\n        if (levelSelects.length > 0 && tierSelects.length > 0) {\n            if (this.props.rootStore.tierFilters && this.props.rootStore.tierFilters.length > 0) {\n                this.props.rootStore.setLevelFilters(levelSelects);\n            } else {\n                this.props.rootStore.setTierFilters(tierSelects);\n            }\n        } else if (levelSelects.length > 0) {\n            this.props.rootStore.setLevelFilters(levelSelects);\n        } else {\n            this.props.rootStore.setTierFilters(tierSelects);\n        }\n    }\n}\n\n@inject('labels', 'rootStore')\n@observer\nclass SiteSelect extends IPTTMultiselectCheckboxWrapper {\n    onChange = (selected) => {\n        this.props.rootStore.setSiteFilters(selected);\n    }\n    get value() {\n        return this.props.rootStore.siteFilters;\n    }\n    get options() {\n        return this.props.rootStore.selectedProgram.reportSites;\n    }\n    get label() {\n        return this.props.labels.siteSelect;\n    }\n}\n\n\n@inject('labels', 'rootStore')\n@observer\nclass TypeSelect extends IPTTMultiselectCheckboxWrapper {\n    onChange = (selected) => {\n        this.props.rootStore.setTypeFilters(selected);\n    }\n    get options() {\n        return this.props.rootStore.selectedProgram.reportTypes;\n    }\n    get value() {\n        return this.props.rootStore.typeFilters;\n    }\n    get label() {\n        return this.props.labels.typeSelect;\n    }\n}\n\n@inject('labels', 'rootStore')\n@observer\nclass SectorSelect extends IPTTMultiselectCheckboxWrapper {\n    onChange = (selected) => {\n        this.props.rootStore.setSectorFilters(selected);\n    }\n    get options() {\n        return this.props.rootStore.selectedProgram.reportSectors;\n    }\n    get value() {\n        return this.props.rootStore.sectorFilters;\n    }\n    get label() {\n        return this.props.labels.sectorSelect;\n    }\n}\n\n\n@inject('labels', 'rootStore')\n@observer\nclass IndicatorSelect extends IPTTMultiselectCheckboxWrapper {\n    onChange = (selected) => {\n        this.props.rootStore.setIndicatorFilters(selected);\n    }\n    get options() {\n        return this.props.rootStore.selectedProgram.reportIndicatorsOptions;\n    }\n    get value() {\n        return this.props.rootStore.indicatorFilters;\n    }\n    get label() {\n        return this.props.labels.indicatorSelect;\n    }\n}\n\n\nconst IPTTFilterForm = inject('labels')(\n    observer(({labels}) => {\n        return <nav id=\"id_iptt_report_filter\">\n                    <div className=\"p-3\" id=\"filter-top\">\n                        <h3 className=\"filter-title text-title-case\">{ labels.filterTitle }</h3>\n                        <ProgramSelect />\n                        <PeriodSelect />\n                        <TimeFrameRadio />\n                        <StartDateSelect />\n                        <EndDateSelect />\n                        <GroupingSelect />\n                    </div>\n                    <div id=\"filter-middle\" className=\"p-3\">\n                        <LevelSelect />\n                        <SiteSelect />\n                        <TypeSelect />\n                        <SectorSelect />\n                        <IndicatorSelect />\n                    </div>\n                </nav>;\n    })\n);\n\nexport default IPTTFilterForm;","// fixtures for building/testing\nexport const contextFixture = {\n    labels: {\n        filterTitle: \"Report options\",\n        reportTitle: \"Indicator performance tracking table\",\n        sidebarToggle: \"Show/hide filters\",\n        pin: 'Pin',\n        excel: 'Excel',\n        programSelect: 'Program',\n        periodSelect: {\n            tva: 'Target periods',\n            timeperiods: 'Time periods'\n        },\n        showAll: 'Show all',\n        mostRecent: 'Most recent',\n        startPeriod: 'Start',\n        endPeriod: 'End',\n        timeperiods: {\n            3: 'Years',\n            4: 'Semi-annual periods',\n            5: 'Tri-annual periods',\n            6: 'Quarters',\n            7: 'Months'\n        },\n        targetperiods: {\n            2: 'Midline and endline',\n            3: 'Annual',\n            4: 'Semi-annual',\n            5: 'Tri-annual',\n            6: 'Quarterly',\n            7: 'Monthly'\n        },\n        periodNames: {\n            3: 'Year',\n            4: 'Semi-annual period',\n            5: 'Tri-annual period',\n            6: 'Quarter'\n        },\n        columnHeaders: {\n            lop: 'Life of Program',\n            number: 'No.',\n            indicator: 'Indicator',\n            level: 'Level',\n            uom: 'Unit of measure',\n            change: 'Change',\n            cumulative: 'C / NC',\n            numType: '# / %',\n            baseline: 'Baseline',\n            target: 'Target',\n            actual: 'Actual',\n            met: '% Met'\n        }\n        \n    },\n    programs: [\n        {\n            name: \"TolaData Demo\",\n            id: 542,\n            frequencies: [3, 5, 6],\n            periodDateRanges: {\n                1: [\n                    [\n                        'Apr 1, 2018',\n                        'Jun 30, 2019'\n                    ]\n                ],\n                2: [\n                    [\n                        'Apr 1, 2018',\n                        'Jun 30, 2019'\n                    ]\n                ],\n                3: [\n                    [\n                        'Apr 1, 2018',\n                        'Jun 30, 2019'\n                    ]\n                ],\n                4: [\n                    [\n                        'Apr 1, 2018',\n                        'Sept 30, 2018'\n                    ],\n                    [\n                        'Oct 1, 2018',\n                        'Mar 31, 2019'\n                    ],\n                    [\n                        'Apr 1, 2019',\n                        'Sept 30, 2019',\n                        true\n                    ]\n                ],\n                5: [\n                    [\n                        'Apr 1, 2018',\n                        'Jul 31, 2018'\n                    ],\n                    [\n                        'Aug 1, 2018',\n                        'Nov 30, 2018'\n                    ],\n                    [\n                        'Dec 1, 2018',\n                        'Apr 30, 2018'\n                    ],\n                    [\n                        'May 1, 2018',\n                        'Aug 31, 2018',\n                        true\n                    ]\n                ],\n                6: [\n                    [\n                        'Apr 1, 2018',\n                        'Jun 30, 2018'\n                    ],\n                    [\n                        'Jul 1, 2018',\n                        'Sept 30, 2018'\n                    ],\n                    [\n                        'Oct 1, 2018',\n                        'Dec 31, 2018'\n                    ],\n                    [\n                        'Jan 1, 2019',\n                        'Mar 31, 2019'\n                    ],\n                    [\n                        'Apr 1, 2019',\n                        'Jun 30, 2019',\n                        true\n                    ]\n                ],\n                7: [\n                    [\n                        'Apr 1, 2018',\n                        'Apr 30, 2018',\n                        'April',\n                        '2018'\n                    ],\n                    [\n                        'May 1, 2018',\n                        'May 31, 2018',\n                        'May',\n                        '2018'\n                    ],\n                    [\n                        'June 1, 2018',\n                        'June 30, 2018',\n                        'June',\n                        '2018'\n                    ],\n                    [\n                        'July 1, 2018',\n                        'July 31, 2018',\n                        'July',\n                        '2018'\n                    ],\n                    [\n                        'Aug 1, 2018',\n                        'Aug 31, 2018',\n                        'August',\n                        '2018'\n                    ],\n                    [\n                        'Sept 1, 2018',\n                        'Sept 30, 2018',\n                        'September',\n                        '2018'\n                    ],\n                    [\n                        'Oct 1, 2018',\n                        'Oct 31, 2018',\n                        'October',\n                        '2018'\n                    ],\n                    [\n                        'Nov 1, 2018',\n                        'Nov 30, 2018',\n                        'November',\n                        '2018'\n                    ],\n                    [\n                        'Dec 1, 2018',\n                        'Dec 31, 2018',\n                        'December',\n                        '2018'\n                    ],\n                    [\n                        'Jan 1, 2019',\n                        'Jan 31, 2019',\n                        'January',\n                        '2019'\n                    ],\n                    [\n                        'Feb 1, 2019',\n                        'Feb 28, 2019',\n                        'February',\n                        '2019'\n                    ],\n                    [\n                        'Mar 1, 2019',\n                        'Mar 31, 2019',\n                        'March',\n                        '2019'\n                    ],\n                    [\n                        'Apr 1, 2019',\n                        'Apr 30, 2019',\n                        'April',\n                        '2019',\n                        true\n                    ],\n                    [\n                        'May 1, 2019',\n                        'May 31, 2019',\n                        'May',\n                        '2019',\n                        true\n                    ],\n                    [\n                        'Jun 1, 2019',\n                        'Jun 30, 2019',\n                        'June',\n                        '2019',\n                        true\n                    ]\n                ]\n            }\n        },\n        {\n            name: \"TolaData Test\",\n            id: 442,\n            frequencies: [2, 3, 4],\n            periodDateRanges: {\n                1: [\n                    [\n                        'Apr 1, 2016',\n                        'Mar 31, 2017'\n                    ]\n                ],\n                2: [\n                    [\n                        'Apr 1, 2016',\n                        'Mar 31, 2017'\n                    ]\n                ],\n                3: [\n                    [\n                        'Apr 1, 2016',\n                        'Mar 31, 2017'\n                    ]\n                ],\n                4: [\n                    [\n                        'Apr 1, 2016',\n                        'Sept 30, 2016'\n                    ],\n                    [\n                        'Oct 1, 2016',\n                        'Mar 31, 2017'\n                    ]\n                ],\n                5: [\n                    [\n                        'Apr 1, 2016',\n                        'Jul 31, 2016'\n                    ],\n                    [\n                        'Aug 1, 2016',\n                        'Nov 30, 2016'\n                    ],\n                    [\n                        'Dec 1, 2016',\n                        'Mar 31, 2017'\n                    ]\n                ],\n                6: [\n                    [\n                        'Apr 1, 2016',\n                        'Jun 30, 2016'\n                    ],\n                    [\n                        'Jul 1, 2016',\n                        'Sept 30, 2016'\n                    ],\n                    [\n                        'Oct 1, 2016',\n                        'Dec 31, 2016'\n                    ],\n                    [\n                        'Jan 1, 2017',\n                        'Mar 31, 2017'\n                    ]\n                ],\n                7: [\n                    [\n                        'Apr 1, 2016',\n                        'Apr 30, 2016',\n                        'April',\n                        '2016'\n                    ],\n                    [\n                        'May 1, 2016',\n                        'May 31, 2016',\n                        'May',\n                        '2016'\n                    ],\n                    [\n                        'June 1, 2016',\n                        'June 30, 2016',\n                        'June',\n                        '2016'\n                    ],\n                    [\n                        'July 1, 2016',\n                        'July 31, 2016',\n                        'July',\n                        '2016'\n                    ],\n                    [\n                        'Aug 1, 2016',\n                        'Aug 31, 2016',\n                        'August',\n                        '2016'\n                    ],\n                    [\n                        'Sept 1, 2016',\n                        'Sept 30, 2016',\n                        'September',\n                        '2016'\n                    ],\n                    [\n                        'Oct 1, 2016',\n                        'Oct 31, 2016',\n                        'October',\n                        '2016'\n                    ],\n                    [\n                        'Nov 1, 2016',\n                        'Nov 30, 2016',\n                        'November',\n                        '2016'\n                    ],\n                    [\n                        'Dec 1, 2016',\n                        'Dec 31, 2016',\n                        'December',\n                        '2016'\n                    ],\n                    [\n                        'Jan 1, 2017',\n                        'Jan 31, 2017',\n                        'January',\n                        '2017'\n                    ],\n                    [\n                        'Feb 1, 2017',\n                        'Feb 28, 2017',\n                        'February',\n                        '2017'\n                    ],\n                    [\n                        'Mar 1, 2017',\n                        'Mar 31, 2017',\n                        'March',\n                        '2017'\n                    ]\n                ]\n            }\n        }\n    ]\n};\n\n\nexport const reportData = {\n    542: {\n        programId: 542,\n        indicators: [\n            {\n                id: 5145,\n                number: '1.1',\n                name: 'Number of reported incidents of violence',\n                level: 'Outcome',\n                unitOfMeasure: 'Reported Incidents of Violence',\n                directionOfChange: '-',\n                cumulative: 'Non-cumulative',\n                unitType: '#',\n                baseline: '600',\n                lopTarget: '200',\n                lopActual: '1333',\n                lopMet: '666.5%'\n            },\n            {\n                id: 5147,\n                number: '2.1',\n                name: 'Number of individuals receiving emergency relief services showing change in assessed conditions.',\n                level: 'Output',\n                unitOfMeasure: 'Individuals',\n                directionOfChange: '+',\n                cumulative: 'Non-cumulative',\n                unitType: '%',\n                baseline: '0',\n                lopTarget: '20000',\n                lopActual: '11925',\n                lopMet: '59.6%'\n            }\n        ],\n    }\n};","/*\n * ID generating code &c. for form inputs\n */\n\nlet lastId = 0;\n\nexport function uniqueId (prefix='id') {\n    lastId++;\n    return `${prefix}${lastId}`;\n}","/*\n  Some nice helper functions to help with date parsing and localization\n\n  In the future it may make sense to use moment.js, luxon, or date-fns,\n  but for now, just get by with the native browser APIs and save some bytes.\n\n  Confusingly, native Date() objects are actually date/time objects.\n\n  Surprisingly, the Django i18n/l10n JS tools do not provide access to the language code\n  of the current language in use.\n */\n\n// Returns a trimmed level ontology for display purposes\nexport function trimOntology(ontologyStr) {\n    let ontologyArray = ontologyStr.split(\".\");\n    return ontologyArray.slice(1).filter(i => i > 0).join(\".\")\n}\n","/**\n * Data models for the IPTT report reqct page\n * @module iptt_report/models\n */\n\nimport {observable, action, computed} from \"mobx\";\nimport { trimOntology } from '../../level_utils'\n\n/**\n * models list:\n * ReportStore (observable - all data for report)\n * ProgramStore (observable - all program options)\n */\n\nconst BLANK_LABEL = '---------';\nconst TVA = 1;\nconst TIMEPERIODS = 2;\n\nexport class ReportAPI {\n    constructor(ajaxUrl) {\n        this.url = ajaxUrl;\n    }\n    \n    callForData(programId, frequency, tva) {\n        let params = {\n            programId: programId,\n            frequency: frequency,\n            reportType: tva ? 'tva' : 'timeperiods'\n        };\n        return $.get(this.url, params);\n    }\n}\n\nclass Level {\n    constructor(program, levelJSON) {\n        this.program = program;\n        this.id = levelJSON.id;\n        this.name = levelJSON.name;\n        this.tier = levelJSON.tier;\n        this.tierPk = levelJSON.tierPk;\n        this.ontology = levelJSON.ontology;\n        this.parentPk = levelJSON.parent;\n        this.displayOntology = trimOntology(this.ontology);\n        this.depth = levelJSON.depth;\n        this.level2parent = levelJSON.level2parent;\n        this.sortIndex = levelJSON.sort;\n    }\n    \n    @computed get indicators() {\n        return this.program.filteredIndicators\n               ? this.program.filteredIndicators.filter(indicator => indicator.levelId == this.id)\n               : [];\n    }\n    \n    @computed get allIndicators() {\n        return this.program.allIndicators\n               ? this.program.allIndicators.filter(indicator => indicator.levelId == this.id)\n               : [];\n    }\n    \n    /** label for the row in the IPTT report, either Goal: goal name or Outcome 1: outcome name */\n    get titleRow() {\n        return `${this.tier}` + (this.displayOntology ? ` ${this.displayOntology}` : '') + `: ${this.name}`;\n    }\n    \n    get optionName() {\n        return this.tier + ' ' + this.sortIndex + ' and sub-levels: ' + this.name;\n    }\n\n}\n\nclass Indicator {\n    @observable timeperiodsData = {};\n    @observable tvaData = {};\n    @observable id = null;\n\n    constructor(program) {\n        this.program = program;\n    }\n\n    loadData(data) {\n        this.id = data.id;\n        this.pk = data.id;\n        this.sortIndex = data.sortIndex;\n        this.number = data.number;\n        this.name = data.name;\n        this.level = data.level;\n        this.tierDepth = data.tierDepth;\n        this.levelId = data.levelpk;\n        this.levelOrder = data.levelOrder;\n        this.sites = data.sites;\n        this.types = data.indicatorTypes;\n        this.sector = data.sector;\n        this.frequency = data.frequency;\n        this.directionOfChange = data.directionOfChange;\n        this.unitOfMeasure = data.unitOfMeasure;\n        this.cumulative = data.cumulative;\n        this.unitType = data.unitType;\n        this.baseline = data.baseline;\n        this.lopTarget = data.lopTarget;\n        this.lopActual = data.lopActual;\n        this.lopMet = data.lopMet;\n        if (data.reportData) {\n            this.loadReportData(data.reportData);\n        }\n    }\n    \n    loadReportData(reportData) {\n        if (reportData.timeperiods) {\n            Object.entries(reportData.timeperiods).forEach(\n                ([frequency, values]) => {\n                    this.timeperiodsData[frequency] = values;\n                }\n            )\n        }\n        if (reportData.tva) {\n            Object.entries(reportData.tva).forEach(\n                ([frequency, values]) => {\n                    this.tvaData[frequency] = values;\n                }\n            )\n        }\n    }\n    \n    @computed get indicatorData() {\n        let frequency = String(this.program.rootStore.selectedFrequencyId);\n        let reportData = this.program.rootStore.isTVA\n                         ? this.tvaData\n                         : this.timeperiodsData;\n        if (reportData[frequency]) {\n            return reportData[frequency]\n                   .slice(this.program.rootStore.startPeriod,\n                          parseInt(this.program.rootStore.endPeriod) + 1);\n        }\n        return false;\n    }\n    \n    get isPercent() {\n        return this.unitType == '%';\n    }\n    \n    get numberDisplay() {\n        if (this.program.levels[this.levelId]) {\n            let level = this.program.levels[this.levelId];\n            return `${level.tier} ${level.displayOntology}${this.levelOrder}`;\n        }\n        return this.number;\n    }\n    \n}\n\n\nclass Program {\n    @observable indicators = null;\n    @observable levels = null;\n    @observable resultChainFilter = 'loading';\n    @observable resultChainHeader = 'loading';\n    @observable reportsLoaded = {\n        tva: [],\n        timeperiods: []\n    };\n\n    constructor(rootStore, programJSON) {\n        this.rootStore = rootStore;\n        this.id = programJSON.id;\n        this.name = programJSON.name;\n        this.frequencies = programJSON.frequencies;\n        this.periodDateRanges = programJSON.periodDateRanges;\n    }\n    \n    periods(frequency) {\n        return frequency in this.periodDateRanges ? this.periodDateRanges[frequency] : false;\n    }\n    \n    periodCount(frequency) {\n        return this.periods(frequency) ? this.periods(frequency).length : 0;\n    }\n    \n    currentPeriod(frequency) {\n        let periods = this.periods(frequency);\n        if (!periods) {\n            return null;\n        } else if (frequency == 7) {\n            return periods.filter((period) => !period[4]).length - 1;\n        } else {\n            return periods.filter((period) => !period[2]).length - 1;\n        }\n    }\n    \n    @action\n    loadData(data) {\n        if (!(data.programId == this.id)) {\n            //something went wrong\n            console.log(\"what happened?  data\", data);\n        }\n        if (this.levels === null) {\n            this.levels = {};\n        }\n        data.levels.forEach(\n            levelJSON => {\n                if (this.levels[levelJSON.id] == undefined) {\n                    this.levels[levelJSON.id] = new Level(this, levelJSON);\n                }\n            }\n        )\n        if (this.indicators === null) {\n            this.indicators = {};\n        }\n        data.indicators.forEach(\n            (indicatorJSON) => {\n                if (this.indicators[indicatorJSON.id] == undefined) {\n                    this.indicators[indicatorJSON.id] = new Indicator(this);\n                }\n                this.indicators[indicatorJSON.id].loadData(indicatorJSON);\n            }\n        );\n        if (data.resultChainFilter) {\n            this.resultChainFilter = data.resultChainFilter;\n        }\n        if (data.resultChainHeader) {\n            this.resultChainHeader = data.resultChainHeader;\n        }\n        this.reportsLoaded[data.reportType].push(String(data.reportFrequency));\n    }\n    \n    @computed get levelsChain() {\n        if (!this.levels || this.levels.length == 0) {\n            return false;\n        }\n        let levels = Object.values(this.levels)\n                .sort((levelA, levelB) => levelA.ontology < levelB.ontology ? -1 : 1);\n        if (false && this.rootStore.filtersApplied) {\n            levels = levels.filter(level => level.indicators.length > 0)\n        }\n        return levels;\n    }\n    \n    @computed get levelsGrouped() {\n        if (!this.levels || this.levels.length == 0) {\n            return false;\n        }\n        function groupCompare(a, b) {\n            if (a.depth < b.depth) {\n                return -1;\n            } else if (a.depth > b.depth) {\n                return 1;\n            } else if (a.ontology < b.ontology) {\n                return -1;\n            } else if (b.ontology < a.ontology) {\n                return 1;\n            }\n            return 0;\n        }\n        let levels = Object.values(this.levels)\n                           .sort(groupCompare);\n        if (false && this.rootStore.filtersApplied) {\n            levels = levels.filter(level => level.indicators.length > 0)\n        }\n        return levels;\n    }\n    \n    @computed get allNoLevelIndicators() {\n        return this.allIndicators ? this.allIndicators.filter(indicator => !indicator.levelId) : false;\n    }\n    \n    @computed get filteredNoLevelIndicators() {\n        return this.filteredIndicators ? this.filteredIndicators.filter(indicator => !indicator.levelId) : false;\n    }\n    \n    @computed get thisReportNotLoaded() {\n        return ((this.rootStore.isTVA\n                 && this.reportsLoaded.tva.indexOf(String(this.rootStore.selectedFrequencyId)) == -1) ||\n                (!this.rootStore.isTVA\n                 && this.reportsLoaded.timeperiods.indexOf(String(this.rootStore.selectedFrequencyId)) == -1));\n    }\n    \n    @computed get allIndicators() {\n        if (!this.indicators || this.indicators.length == 0) {\n            return false;\n        } else {\n            return Object.values(this.indicators).sort((a, b) => a.sortIndex - b.sortIndex);\n        }\n    }\n    \n    @computed get filteredIndicators() {\n        let indicators = this.allIndicators;\n        if (!indicators) {\n            return false;\n        }\n        indicators = this.rootStore.filterOnTiers(indicators);\n        indicators = this.rootStore.filterOnLevelChains(indicators);\n        indicators = this.rootStore.filterOnSites(indicators);\n        indicators = this.rootStore.filterOnTypes(indicators);\n        indicators = this.rootStore.filterOnSectors(indicators);\n        indicators = this.rootStore.filterOnIndicatorIds(indicators);\n        return indicators;\n    }\n    \n    @computed get reportLevelTiers() {\n        if (!this.levelsChain) {\n            return [];\n        }\n        return [...new Set(this.levelsChain.filter(\n            level => level.allIndicators && level.allIndicators.length > 0\n        ).map(level => ({label: level.tier, value: level.tierPk,\n                         sortIndex: level.depth, filterType: 'tier'})\n        ).map(JSON.stringify))].map(JSON.parse);\n    }\n\n    @computed get reportLevelChains() {\n        if (!this.levelsChain) {\n            return [];\n        }\n        let level2s = this.levelsChain.filter(\n            level => level.depth == this.rootStore.levelFilterDepth\n        );\n        let indicatorCounts = {};\n        level2s.forEach(\n            level2 => indicatorCounts[level2.id] = level2.allIndicators.length\n        );\n        this.levelsChain.filter(\n            level => level.level2parent\n        ).forEach(\n            level => indicatorCounts[level.level2parent] += level.allIndicators.length\n        )\n        level2s = level2s.filter(\n            level2 => indicatorCounts[level2.id]\n        );\n        return [...new Set(\n            level2s.map(level => ({label: level.optionName, value: level.id,\n                         sortIndex: level.sort, filterType: 'level'})\n            ).map(JSON.stringify))].map(JSON.parse);\n    }\n    \n    @computed get reportSites() {\n        let indicators = this.allIndicators;\n        if (!indicators || indicators.length == 0) {\n            return [];\n        }\n        let sites = indicators.map(indicator => indicator.sites)\n                        .reduce((pre, cur) => {return pre.concat(cur)})\n                        .map((elem) => ({value: elem.pk, label: elem.name}))\n                        .filter(elem => elem.label != '');\n        return [...new Set(sites.map(JSON.stringify))].map(JSON.parse);\n    }\n    \n    @computed get reportTypes() {\n        let indicators = this.allIndicators;\n        if (!indicators || indicators.length == 0) {\n            return [];\n        }\n        return [...new Set(\n            indicators.map(indicator => indicator.types)\n                        .reduce((pre, cur) => {return pre.concat(cur)})\n                        .map((elem) => ({value: elem.pk, label: elem.name}))\n                        .map(JSON.stringify))].map(JSON.parse);\n    }\n    \n    @computed get reportSectors() {\n        let indicators = this.allIndicators;\n        if (!indicators || indicators.length == 0) {\n            return [];\n        }\n        return [...new Set(\n            indicators.map(\n                indicator => JSON.stringify({value: indicator.sector.pk, label:indicator.sector.name}))\n            )].map(JSON.parse).filter(elem => elem.label != '');\n    }\n    \n    @computed get reportIndicatorsOptions() {\n        let levels = this.rootStore.levelGrouping ? this.levelsGrouped : this.levelsChain;\n        if (!levels || levels.length == 0) {\n            return [];\n        }\n        let indicators = levels.map(\n            level => ({\n                label: level.tier + ' ' + level.displayOntology,\n                options: level.allIndicators.map(indicator => ({value: indicator.pk,\n                                                               label: `${indicator.numberDisplay}: ${indicator.name}`}))\n            })\n        );\n        return indicators;\n    }\n\n}\n\nclass ProgramStore  {\n    constructor(rootStore, programsJSON) {\n        this.rootStore = rootStore;\n        this.programs = {};\n        programsJSON.forEach(programJSON => {\n            this.programs[programJSON.id] = new Program(this.rootStore, programJSON);\n        });\n    }\n    \n    getProgram(id) {\n        return this.programs[id];\n    }\n\n}\n\nexport class RootStore {\n    @observable selectedProgram = null;\n    @observable selectedFrequencyId = null;\n    @observable startPeriod = '';\n    @observable endPeriod = '';\n    @observable nullRecent = false;\n    @observable levelGrouping = false;\n    @observable levelFilters = [];\n    @observable tierFilters = [];\n    @observable siteFilters = [];\n    @observable typeFilters = [];\n    @observable sectorFilters = [];\n    @observable indicatorFilters = [];\n    @observable noIndicatorsForFrequency = false;\n    @observable loading = false;\n    @observable initialized = false;\n    noLevelRowLabel = 'No level';\n    reportType = null;\n    router = null;\n    currentPeriod = null;\n    \n    headerCols = 8;\n    lopCols = 3;\n    levelFilterDepth = 2;\n    \n    \n    constructor(contextData, reportAPI) {\n        this.programStore = new ProgramStore(this, contextData.programs);\n        this.noLevelRowLabel = contextData.labels.noLevelIndicatorsRowLabel;\n        this.reportAPI = reportAPI;\n        this._periodLabels = {\n            [TIMEPERIODS]: contextData.labels.timeperiods,\n            [TVA]: contextData.labels.targetperiods,\n            names: contextData.labels.periodNames\n        };\n    }\n    \n    init = (router) => {\n        this.router = router;\n        this.loading = true;\n        let params = router.getState().params;\n        let reload = false;\n        this.setProgramId(params.programId);\n        this.setReportType(params.reportType);\n        if (params.timeperiods || params.targetperiods) {\n            params.frequency = params.timeperiods || params.targetperiods;\n            delete params['timeperiods'];\n            delete params['targetperiods'];\n            reload = true;\n        }\n        this.setFrequencyId(params.frequency);\n        if (params.timeframe == 1) {\n            params.start = 0;\n            params.end = this.selectedProgram.periodDateRanges[params.frequency].length - 1;\n            delete params['timeframe'];\n            reload = true;\n        } else if (params.timeframe == 2) {\n            let numrecent = params.numrecentperiods || 2;\n            params.end = this.selectedProgram.currentPeriod(params.frequency);\n            params.start = params.end - numrecent + 1;\n            delete params['timeframe'];\n            delete params['numrecentperiods'];\n            reload = true;\n        } else if (params.start === undefined || params.end === undefined) {\n            params.start = 0;\n            params.end = this.selectedProgram.periodDateRanges[params.frequency].length - 1;\n            delete params['timeframe'];\n            delete params['numrecentperiods'];\n            delete params['start_period'];\n            delete params['end_period'];\n            reload = true;\n        }\n        this.setStartPeriod(params.start);\n        this.setEndPeriod(params.end);\n        this.levelGrouping = params.groupby;\n        if (reload) {\n            router.navigate(router.getState().name, params, {reload: true});\n        }\n        this.loading = false;\n        this.callForData();\n    }\n    \n    updateUrl = (param, newValue) => {\n        let oldParams = this.router.getState().params;\n        if (newValue !== null && oldParams[param] != newValue) {\n            let newParams = { ...oldParams, [param]: newValue };\n            this.router.navigate(this.router.getState().name, newParams, {replace: true});\n        }\n    }\n    \n    @computed get pinData() {\n        if (!this.selectedProgram) {\n            return false;\n        }\n        let queryString = window.location.search;\n        queryString = queryString && queryString.length > 0 && queryString[0] == '?' ? queryString.slice(1) : queryString;\n        return !this.selectedProgram ? false : {\n            program: this.selectedProgram.id,\n            report_type: this.router.getState().params.reportType,\n            query_string: queryString\n        };\n    }\n    \n    @computed get programPageUrl() {\n        return this.selectedProgram ? '/program/' + this.selectedProgram.id + '/' : false;\n    }\n    \n    @computed get currentExcelURL() {\n        let params = this.router.getState().params;\n        let url = '/indicators/iptt_excel/' + window.location.search;\n        url += '&programId=' + this.selectedProgram.id;\n        url += '&reportType=' + (this.isTVA ? 'tva' : 'timeperiods');\n        return url;\n    }\n    \n    @computed get allExcelURL() {\n        let params = this.router.getState().params;\n        let url = '/indicators/iptt_excel/?frequency=all';\n        url += '&programId=' + this.selectedProgram.id;\n        url += '&reportType=' + (this.isTVA ? 'tva' : 'timeperiods');\n        return url;\n    }\n    \n    updateRoute = ({ previousRoute, route }) => {\n        //console.log(\"updating route from\", previousRoute, \"  to \", route);\n    }\n    \n    // REPORT TYPE:\n    \n    setReportType(reportType) {\n        if (reportType == 'timeperiods') {\n            this.reportType = TIMEPERIODS;\n        } else {\n            this.reportType = TVA;\n        }\n    }\n    \n    get isTVA() {\n        return (this.reportType === TVA);\n    }\n\n    @computed get filtersApplied() {\n        return (this.levelFilters.length > 0 ||\n                this.tierFilters.length > 0 ||\n                this.siteFilters.length > 0 ||\n                this.typeFilters.length > 0 ||\n                this.sectorFilters.length > 0 ||\n                this.indicatorFilters.length > 0);\n    }\n    \n    @computed get report() {\n        let levels;\n        if (this.selectedProgram === null || !this.selectedFrequencyId) {\n            return [];\n        }\n        else if (this.levelGrouping) {\n            levels = this.selectedProgram.levelsGrouped;\n        } else {\n            levels = this.selectedProgram.levelsChain;\n        }\n        if (this.selectedProgram.filteredNoLevelIndicators &&\n            this.selectedProgram.filteredNoLevelIndicators.length > 0) {\n            levels = levels.concat([{titleRow: this.noLevelRowLabel,\n                                    indicators: this.selectedProgram.filteredNoLevelIndicators}]);\n        }\n        if (levels && this.filtersApplied) {\n            levels = levels.filter(level => level.indicators.length > 0);\n        }\n        if (levels) {\n            return levels;\n        }\n        return false;\n    }\n    \n    filterOnTiers(indicators) {\n        if (this.tierFilters && this.tierFilters.length > 0) {\n            let tierDepths = this.tierFilters.map(tierOption => tierOption.sortIndex);\n            indicators = indicators.filter(\n                (indicator) => tierDepths.indexOf(indicator.tierDepth) != -1\n            );\n        }\n        return indicators;\n    }\n    \n    filterOnLevelChains(indicators) {\n        if (this.levelFilters && this.levelFilters.length > 0) {\n            let level2Pks = this.levelFilters.map(levelOption => levelOption.value);\n            let levelIds = this.selectedProgram.levelsGrouped.filter(\n                level => level2Pks.indexOf(level.level2parent) != -1\n            ).map( level => level.id );\n            indicators = indicators.filter(\n                (indicator) => (levelIds.indexOf(indicator.levelId) != -1 || level2Pks.indexOf(indicator.levelId) != -1)\n            );\n        }\n        return indicators;\n    }\n    \n    filterOnTypes(indicators) {\n        if (this.typeFilters && this.typeFilters.length > 0) {\n            let typePks = this.typeFilters.map(typeOption => typeOption.value);\n            indicators = indicators.filter(\n                (indicator) => indicator.types.map(iType => iType.pk).filter(pk => typePks.includes(pk)).length > 0\n            );\n        }\n        return indicators;\n    }\n    \n    filterOnSectors(indicators) {\n        if (this.sectorFilters && this.sectorFilters.length > 0) {\n            indicators = indicators.filter(\n                indicator => this.sectorFilters.map(sectorOption => sectorOption.value).indexOf(indicator.sector.pk) != -1\n            );\n        }\n        return indicators;\n    }\n    \n    filterOnSites(indicators) {\n        if (this.siteFilters && this.siteFilters.length > 0) {\n            let sitePks = this.siteFilters.map(siteOption => siteOption.value);\n            indicators = indicators.filter(\n                (indicator) => indicator.sites.map(site => site.pk).filter(pk => sitePks.includes(pk)).length > 0\n            );\n        }\n        return indicators;\n    }\n    \n    filterOnIndicatorIds(indicators) {\n        if (this.indicatorFilters && this.indicatorFilters.length > 0) {\n            indicators = indicators.filter(\n                indicator => this.indicatorFilters.map(indicatorOption => indicatorOption.value).indexOf(indicator.pk) != -1\n            );\n        }\n        return indicators;\n    }\n\n    callForData = () => {\n        if (!this.loading) {\n            this.loading = true;\n            this.reportAPI.callForData(this.selectedProgram.id, this.selectedFrequencyId, this.isTVA)\n                .then((data) => {\n                    this.selectedProgram.loadData(data);\n                    this.updateFilters();\n                    this.loading=false;\n                    this.initialized=true;\n                    });\n        }\n    }\n    \n    updateFilters = () => {\n        let params = this.router.getState().params;\n        if (params.frequency && this.isTVA\n                && this.selectedProgram.frequencies.indexOf(parseInt(params.frequency)) == -1) {\n                this.noIndicatorsForFrequency = true;\n                this.setFrequencyId(null);\n        }\n        if (params.levels) {\n            let levels = params.levels instanceof(Array) ? params.levels.map(Number) : [params.levels].map(Number);\n            this.levelFilters = this.selectedProgram.reportLevelChains.filter(\n                levelOption => levels.indexOf(levelOption.value) != -1\n            );\n            this.updateUrl('levels', this.levelFilters.map(levelOption => levelOption.value));\n            if (params.tiers) {\n                this.updateUrl('params', []);\n            }\n        }\n        if (params.tiers) {\n            let tiers = params.tiers instanceof(Array) ? params.tiers.map(Number) : [params.tiers].map(Number);\n            this.tierFilters = this.selectedProgram.reportLevelTiers.filter(\n                tierOption => tiers.indexOf(tierOption.value) != -1\n            );\n            this.updateUrl('tiers', this.tierFilters.map(tierOption => tierOption.value));\n        }\n        if (params.sites) {\n            let sites = params.sites instanceof(Array) ? params.sites.map(Number) : [params.sites].map(Number);\n            this.siteFilters = this.selectedProgram.reportSites.filter(\n                siteOption => sites.indexOf(siteOption.value) != -1\n            );\n            this.updateUrl('sites', this.siteFilters.map(siteOption => siteOption.value));\n        }\n        if (params.types) {\n            let theseTypes = params.types instanceof(Array) ? params.types.map(Number) : [params.types].map(Number);\n            this.typeFilters = this.selectedProgram.reportTypes.filter(\n                typeOption => theseTypes.indexOf(typeOption.value) != -1\n            );\n            this.updateUrl('types', this.typeFilters.map(typeOption => typeOption.value));\n        }\n        if (params.sectors) {\n            let sectors = params.sectors instanceof(Array) ? params.sectors.map(Number) : [params.sectors].map(Number);\n            this.sectorFilters = this.selectedProgram.reportSectors.filter(\n                sectorOption => sectors.indexOf(sectorOption.value) != -1\n            );\n            this.updateUrl('sectors', this.sectorFilters.map(sectorOption => sectorOption.value));\n        }\n        if (params.indicators) {\n            let indicators = params.indicators instanceof (Array) ? params.indicators.map(Number) : [params.indicators].map(Number);\n            this.indicatorFilters = this.selectedProgram.reportIndicatorsOptions.filter(\n                indicatorOption => indicators.indexOf(indicatorOption.value) != -1\n            );\n            this.updateUrl('indicators', this.indicatorFilters.map(indicatorOption => indicatorOption.value));\n        }\n    }\n    \n    // FILTER SECTION:\n    \n    //SELECTING PROGRAMS:\n\n    setProgramId(id) {\n        if (id === null) {\n            this.selectedProgram = null;\n        } else if (this.selectedProgram == null || this.selectedProgram.id != id) {\n            this.noIndicatorsForFrequency = false;\n            this.updateUrl('programId', id);\n            this.selectedProgram = this.programStore.getProgram(id);\n            if (this.isTVA && this.selectedFrequencyId\n                && this.selectedProgram.frequencies.indexOf(parseInt(this.selectedFrequencyId)) == -1) {\n                this.noIndicatorsForFrequency = true;\n                this.setFrequencyId(null);\n            } else if (this.selectedFrequencyId !== null) {\n                this.setFrequencyId(this.selectedFrequencyId);\n                this.updatePeriods();\n            }\n            if (this.selectedFrequencyId !== null && !this.report) {\n                this.callForData();\n            }\n        }\n    }\n    \n    @computed get selectedProgramOption() {\n        if (this.selectedProgram === null) {\n            return {value: null, label: BLANK_LABEL};\n        }\n        return {value: this.selectedProgram.id, label: this.selectedProgram.name};\n    }\n    \n    get programOptions() {\n        // all available options for Programs dropdown:\n        return Object.entries(this.programStore.programs).map(\n            ([id, program]) => ({value: id, label: program.name})\n        );\n    }\n    \n    //SELECTING FREQUENCY:\n    \n    setFrequencyId(id) {\n        if (id === null) {\n            this.selectedFrequencyId = null;\n        } else if (this.selectedFrequencyId != id) {\n            this.selectedFrequencyId = id;\n            this.updateUrl('frequency', id);\n            if (this.isTVA && this.selectedFrequencyId\n                && this.selectedProgram.frequencies.indexOf(parseInt(this.selectedFrequencyId)) != -1) {\n                this.noIndicatorsForFrequency = false;\n            }\n            // refresh periods to make sure they're in range:\n            this.updatePeriods();\n            this.updateCurrentPeriod();\n            // call for data if not loaded:\n            if (this.selectedProgram.thisReportNotLoaded) {\n                this.callForData();\n            }\n        }\n    }\n    \n    updateCurrentPeriod() {\n        this.currentPeriod = this.selectedProgram.currentPeriod(this.selectedFrequencyId);\n    }\n    \n    updatePeriods() {\n        if (this.selectedFrequencyId == 2) {\n            this.setStartPeriod(0);\n            this.setEndPeriod(1);\n        } else {\n            if (this.startPeriod != '') {\n                this.setStartPeriod(this.startPeriod);\n            }\n            if (this.endPeriod != '') {\n                this.setEndPeriod(this.endPeriod);\n            }\n        }\n    }\n    \n    @computed get selectedFrequencyOption() {\n        if (this.selectedProgram === null || this.selectedFrequencyId === null) {\n            return {value: null, label: BLANK_LABEL};\n        }\n        return {\n            value: this.selectedFrequencyId,\n            label: this._periodLabels[this.reportType][this.selectedFrequencyId]\n            };\n    }\n    \n    @computed get frequencyOptions() {\n        if (this.selectedProgram === null) {\n            return [{value: null, label: BLANK_LABEL},];\n        }\n        else if (this.reportType == TIMEPERIODS) {\n            return Object.entries(this._periodLabels[TIMEPERIODS]).map(\n              ([id, label]) => ({value: id, label: label})\n            );\n        } else {\n            return this.selectedProgram.frequencies.map(\n                (id) => ({value: id, label: this._periodLabels[TVA][id]})\n            );\n        }\n    }\n    \n    //PERIODS:\n    \n    setStartPeriod(period) {\n        //use '' for null values as React does badly with null value for select\n        if (this.selectedFrequencyId == 2) {\n            this.startPeriod = 0;\n            this.updateUrl('start', this.startPeriod);\n        } else if (this.selectedFrequencyId && this.selectedProgram) {\n            period = period !== null\n                     ? period < this.selectedProgram.periodCount(this.selectedFrequencyId)\n                        ? period\n                        : 0\n                    : '';\n            this.startPeriod = period;\n            this.updateUrl('start', this.startPeriod);\n        }\n    }\n    \n    setEndPeriod(period) {\n        if (this.selectedFrequencyId == 2) {\n            this.endPeriod = 1;\n            this.updateUrl('end', this.endPeriod);\n        } else if (this.selectedFrequencyId && this.selectedProgram) {\n            this.nullRecent = false;\n            period = period !== null\n                     ? period < this.selectedProgram.periodCount(this.selectedFrequencyId)\n                        ? period\n                        : this.selectedProgram.periodCount(this.selectedFrequencyId) - 1\n                    : '';\n            this.endPeriod = period;\n            this.updateUrl('end', this.endPeriod);\n        }\n    }\n    \n    @computed get startPeriodLabel() {\n        if (this.selectedProgram && this.selectedFrequencyId\n            && this.startPeriod !== null && this.startPeriod !== ''\n            && this.startPeriod <= this.selectedProgram.periodCount(this.selectedFrequencyId)) {\n            return this.selectedProgram.periods(this.selectedFrequencyId)[this.startPeriod][0];\n        }\n        return '';\n    }\n    \n    @computed get endPeriodLabel() {\n        if (this.selectedProgram && this.selectedFrequencyId\n            &&this.endPeriod !== null && this.endPeriod !== ''\n            && this.endPeriod < this.selectedProgram.periodCount(this.selectedFrequencyId)) {\n            return this.selectedProgram.periods(this.selectedFrequencyId)[this.endPeriod][1];\n        }\n        return '';\n    }\n    \n    @computed get selectedPeriods() {\n        if (!this.selectedProgram || !this.selectedFrequencyId || this.selectedFrequencyId === 1\n            || this.startPeriod === null || this.endPeriod === null) {\n            return [];\n        }\n        return this.selectedProgram.periods(this.selectedFrequencyId).slice(this.startPeriod, parseInt(this.endPeriod) + 1);\n    }\n    \n    @computed get periodOptions() {\n        if (this.selectedProgram === null || this.selectedFrequencyId === null) {\n            return [{value: null, label: BLANK_LABEL}];\n        } else if (this.selectedFrequencyId == 7) {\n            let years = {};\n            this.selectedProgram.periodDateRanges[7].forEach(\n                ( period, index ) => {\n                    let label = this.getPeriodLabel(period, index);\n                    let year = period[3];\n                    if (!(year in years)) {\n                        years[year] = [];\n                    }\n                    years[year].push({value: index, label: label.title});\n                }\n            );\n            return years;\n        } else if (this.selectedFrequencyId == 2 || this.selectedFrequencyId == 1) {\n            return this.selectedProgram.periods(this.selectedFrequencyId).map(\n                (labels, index) => {\n                    return {value: index, label: labels[index]}\n                }\n            )\n        }\n        return this.selectedProgram.periods(this.selectedFrequencyId).map(\n            (labels, index) => {\n                let label = this.getPeriodLabel(labels, index);\n                return {value: index, label: label.title + ' ' + '(' + label.subtitle + ')'};\n            }\n        );\n    }\n    \n    getPeriodLabel = (period, index) => {\n        if (this.selectedFrequencyId == 7) {\n            let [, , monthLabel, year] = period;\n            return {title: monthLabel + ' ' + year, subtitle: ''};\n        } else if (this.selectedFrequencyId == 2) {\n            return {title: period[2].toUpperCase(), subtitle: ''};\n        } else {\n            let [startLabel, endLabel] = period;\n            return {title: this._periodLabels.names[this.selectedFrequencyId] + \" \" + (index + 1),\n                    subtitle: startLabel + ' - ' + endLabel};\n        }\n    }\n    \n    // SHOW ALL / MOST RECENT OPTIONS:\n    \n    setShowAll = () => {\n        this.setStartPeriod(0);\n        this.setEndPeriod(this.selectedProgram.periodCount(this.selectedFrequencyId) - 1);\n    }\n    \n    setMostRecent = (numrecent) => {\n        if (numrecent === '') {\n            this.nullRecent = true;\n        } else if (numrecent !== null) {\n            let startPeriod = Math.max(this.currentPeriod - numrecent + 1, 0);\n            this.setEndPeriod(this.currentPeriod);\n            this.setStartPeriod(startPeriod);\n        }\n    }\n    \n    @computed get timeframeEnabled() {\n        //showAll and Most Recent don't make sense for non time-aware frequencies:\n        return (this.selectedProgram && this.selectedFrequencyId != 2 && this.selectedFrequencyId != 1);\n    }\n    \n    @computed get showAll() {\n        return (this.timeframeEnabled && this.startPeriod == 0\n                && this.endPeriod == this.selectedProgram.periodCount(this.selectedFrequencyId) - 1);\n    }\n    \n    @computed get mostRecent() {\n        if (this.nullRecent) {\n            return '';\n        } else if (this.timeframeEnabled && !this.showAll && this.currentPeriod !== null\n            && this.endPeriod == this.currentPeriod) {\n            return this.endPeriod - this.startPeriod + 1;\n        }\n        return null;\n    }\n    \n    setLevelGrouping = (value) => {\n        this.levelGrouping = value == 1;\n        this.updateUrl('groupby', value);\n    }\n    \n    setLevelFilters = (selected) => {\n        this.levelFilters = selected;\n        this.tierFilters = [];\n        this.updateUrl('levels', selected.map(item => item.value));\n        this.updateUrl('tiers', []);\n    }\n    \n    setTierFilters = (selected) => {\n        this.levelFilters = [];\n        this.tierFilters = selected;\n        this.updateUrl('tiers', selected.map(item => item.value));\n        this.updateUrl('levels', []);\n   }\n    \n    setSiteFilters = (selected) => {\n        this.siteFilters = selected;\n        this.updateUrl('sites', selected.map(item => item.value));\n    }\n    \n    setTypeFilters = (selected) => {\n        this.typeFilters = selected;\n        this.updateUrl('types', selected.map(item => item.value));\n    }\n    \n    setSectorFilters = (selected) => {\n        this.sectorFilters = selected;\n        this.updateUrl('sectors', selected.map(item => item.value));\n    }\n    \n    setIndicatorFilters = (selected) => {\n        this.indicatorFilters = selected;\n        this.updateUrl('indicators', selected.map(item => item.value));\n    }\n    \n    clearFilters = () => {\n        this.levelFilters = this.siteFilters = this.typeFilters = this.sectorFilters = this.tierFilters = this.indicatorFilters = [];\n        this.updateUrl('levels', []);\n        this.updateUrl('tiers', []);\n        this.updateUrl('sites', []);\n        this.updateUrl('types', []);\n        this.updateUrl('sectors', []);\n        this.updateUrl('indicators', []);\n    }\n    \n}","import React from 'react';\nimport { observer, inject } from 'mobx-react';\n\n\nconst SubheadCell = (props) => {\n    let tdStyle = {};\n    if (props.minWidth) {\n        tdStyle.minWidth = props.minWidth;\n    }\n    return <th scope=\"col\" className={\"align-bottom text-uppercase \" + (props.classes || '')}\n            style={ tdStyle }>{ props.cellText }</th>;\n}\n\n@inject('labels', 'rootStore')\n@observer\nclass IPTTSubheadRow extends React.Component {\n    getDateRangeHeaders = () => {\n        let headers = [];\n        let periods = this.props.rootStore.selectedPeriods;\n        if (!periods) {\n            return headers;\n        } else if (this.props.rootStore.isTVA) {\n            periods.forEach(\n                (period, index) => {\n                    headers.push(<SubheadCell classes=\"text-right\" minWidth=\"110px\" key={ index + 'a' }\n                            cellText={ this.props.labels.columnHeaders.target} />);\n                    headers.push(<SubheadCell classes=\"text-right\" minWidth=\"110px\" key={ index + 'b' }\n                            cellText={ this.props.labels.columnHeaders.actual} />);\n                    headers.push(<SubheadCell classes=\"text-right\" minWidth=\"110px\" key={ index + 'c' }\n                            cellText={ this.props.labels.columnHeaders.met} />);\n                }\n            );\n        } else {\n            periods.forEach(\n                (period, index) => {\n                    headers.push(<SubheadCell classes=\"text-right\" key={ index }\n                            cellText={ this.props.labels.columnHeaders.actual} />);\n                }\n            );\n        }\n        return headers;\n    }\n    render() {\n        let colLabels = this.props.labels.columnHeaders;\n        return <tr>\n                    <SubheadCell minWidth='120px' cellText={ colLabels.number } />\n                    <SubheadCell minWidth='600px' classes='td-no-side-borders'\n                                 cellText={ colLabels.indicator } />\n                    <SubheadCell classes=\"td-no-side-borders\" />\n                    <SubheadCell minWidth='250px' cellText={ colLabels.uom } />\n                    <SubheadCell cellText={ colLabels.change } />\n                    <SubheadCell minWidth='130px' cellText={ colLabels.cumulative } />\n                    <SubheadCell minWidth='50px' cellText={ colLabels.numType } />\n                    <SubheadCell cellText={ colLabels.baseline } />\n                    <SubheadCell minWidth='110px' classes='text-right td-no-side-borders'\n                        cellText={ colLabels.target } />\n                    <SubheadCell minWidth='110px' classes='text-right td-no-side-borders'\n                        cellText={ colLabels.actual } />\n                    <SubheadCell minWidth='110px' classes='text-right td-no-side-borders'\n                        cellText={ colLabels.met } />\n                    { this.getDateRangeHeaders() }\n               </tr>;\n    }\n}\n\n\n\nexport const IPTTTableHead = inject('labels', 'rootStore')(\n    observer(\n        ({ labels, rootStore }) => {\n            let getDateHeaders = () => {\n                return !(rootStore.selectedPeriods)\n                    ? []\n                    : rootStore.selectedPeriods.map(\n                        (period, count) => {\n                            let label = rootStore.getPeriodLabel(period, count);\n                                return (\n                                    <td scope=\"col\"\n                                        colSpan={ rootStore.isTVA ? '3' : '1'}\n                                        className={\"text-center lopCols text-nowrap align-bottom\" + (rootStore.selectedFrequencyId == 7 ? \" text-uppercase\" : \"\")} \n                                        key={ count + parseInt(rootStore.startPeriod) }>\n                                            { label.title }\n                                            <br />\n                                            <small>{ label.subtitle }</small>\n                                    </td>\n                                    );\n                        }\n                    );\n            }\n            let periodsLength = rootStore.selectedPeriods.length * (rootStore.isTva ? 3 : 1);\n            return (\n                <React.Fragment>\n                    <colgroup scope=\"col\" span={ rootStore.headerCols }></colgroup>\n                    <colgroup scope=\"col\" span={ rootStore.lopCols } className=\"lopCols\"></colgroup>\n                    <colgroup scope=\"col\" span={ periodsLength }></colgroup>\n                    <thead className=\"thead-light\">\n                        <tr>\n                            <td colSpan={ rootStore.headerCols } id=\"id_td_iptt_program_name\"\n                                className=\"lopCols align-bottom pt-2\"> \n                                <h5 className=\"m-0\">\n                                    <strong>{ rootStore.selectedProgram.name }</strong>\n                                </h5>\n                            </td>\n                            <td scope=\"colgroup\" colSpan={ rootStore.lopCols }\n                             className=\"text-center align-bottom text-uppercase\">\n                             { labels.columnHeaders.lop }\n                             </td>\n                             { getDateHeaders() }\n                        </tr>\n                        <IPTTSubheadRow />\n                    </thead>\n                </React.Fragment>\n            );\n        }\n    )\n)","import React from 'react';\nimport { observer, inject } from 'mobx-react';\nimport { IPTTTableHead } from './headerComponents';\n\n\nconst EMPTY_CELL = '—';\n\n\nconst IndicatorTD = observer((props) => {\n    return <td className=\"td-no-side-borders\" {...props}>{props.children}</td>;\n});\n\n\nconst TVAValue = observer(({ target, value, isPercent }) => {\n    let percentText = (value && target && target != 0) ? String(Math.round(value / target * 1000) / 10) + '%' : EMPTY_CELL;\n    let valueText = value ? String(Math.round(value)) + (isPercent ? '%' : '') : EMPTY_CELL;\n    let targetText = target ? String(Math.round(target)) + (isPercent ? '%' : '') : EMPTY_CELL;\n    return <React.Fragment>\n        <td align=\"right\">{targetText}</td>\n        <td align=\"right\">{valueText}</td>\n        <td align=\"right\">{percentText}</td>\n    </React.Fragment>\n});\n\n@inject('rootStore')\n@observer\nclass IndicatorRow extends React.Component {\n    getPeriodValues = () => {\n        if (!this.props.indicator.indicatorData) {\n            return <td key={this.props.index}>Loading</td>;\n        } else if (this.props.rootStore.isTVA) {\n            return this.props.indicator.indicatorData.map(\n                (values, index) => <TVAValue key={index} isPercent={this.props.indicator.isPercent} {...values} />\n            );\n        } else {\n            return this.props.indicator.indicatorData.map(\n                (value, index) => {\n                    return <td key={index} align=\"right\">\n                        {value ? String(Math.round(value)) + (this.props.indicator.isPercent ? '%' : '') : EMPTY_CELL}</td>;\n                }\n            );\n        }\n    }\n    render() {\n        let indicator = this.props.indicator;\n        if (indicator.id === null) {\n            return <Loading />;\n        }\n        let resultsButton = <button type=\"button\" className=\"btn btn-link p-1 indicator-ajax-popup indicator-data\"\n                         data-indicatorid={indicator.id}\n                         data-container=\"body\"\n                         data-trigger=\"focus\"\n                         data-toggle=\"popover\"\n                         data-placement=\"bottom\">\n                            <i className=\"fas fa-table\"></i>\n                        </button>;\n        let updateButton = <a href=\"#\" className=\"indicator-link float-right\">\n                                <i className=\"fas fa-cog\"></i>\n                            </a>;\n        let baseline = indicator.baseline ? String(indicator.baseline) + (indicator.isPercent ? '%' : '') : EMPTY_CELL;\n        let lopTarget = indicator.lopTarget ? String(Math.round(indicator.lopTarget)) + (indicator.isPercent ? '%' : '') : EMPTY_CELL;\n        let lopActual = indicator.lopActual\n                        ? indicator.isPercent\n                            ? String(Math.round(indicator.lopActual * 10)/10) + '%'\n                            : String(Math.round(indicator.lopActual))\n                        : EMPTY_CELL;\n        let lopMet = indicator.lopMet ? String(Math.round(indicator.lopMet * 1000)/10) + '%' : EMPTY_CELL;\n        return <tr>\n                    <IndicatorTD>{ indicator.numberDisplay }</IndicatorTD>\n                    <IndicatorTD>{ resultsButton }  { indicator.name }</IndicatorTD>\n                    <IndicatorTD>{ updateButton }</IndicatorTD>\n                    <IndicatorTD>{ indicator.unitOfMeasure }</IndicatorTD>\n                    <IndicatorTD align=\"center\">{ indicator.directionOfChange }</IndicatorTD>\n                    <IndicatorTD>{ indicator.cumulative }</IndicatorTD>\n                    <IndicatorTD>{ indicator.unitType }</IndicatorTD>\n                    <IndicatorTD align=\"right\">{ baseline }</IndicatorTD>\n                    <IndicatorTD align=\"right\">{ lopTarget }</IndicatorTD>\n                    <IndicatorTD align=\"right\">{ lopActual }</IndicatorTD>\n                    <IndicatorTD align=\"right\">{ lopMet }</IndicatorTD>\n                    { this.getPeriodValues() }\n               </tr>;\n    }\n}\n\nconst Loading = () => {\n    return <tr><td>Loading</td></tr>;\n}\n\nconst NoIndicatorsForFrequency = inject('labels')(({ labels }) => {\n    return <tr><td colSpan=\"8\">{ labels.noIndicatorsForFrequency }</td></tr>;\n});\n\nconst NoIndicatorsForFilters = inject('labels')(({ labels }) => {\n    return <tr><td colSpan=\"8\">{ labels.noIndicatorsForFilters }</td></tr>;\n})\n\nconst LevelRow = inject('rootStore')(\nobserver(\n    ({ level, rootStore }) => {\n        const indicators = level.indicators\n                           ? level.indicators.map(\n                                (indicator, count) => <IndicatorRow indicator={indicator} key={count} />\n                            ) : null;\n        const width = rootStore.headerCols + rootStore.lopCols +\n                      (rootStore.selectedPeriods.length * (rootStore.isTva ? 3 : 1));\n        return (\n            <React.Fragment>\n                <tr className=\"row__level\">\n                    <td colSpan={ width }>\n                        { level.titleRow }\n                    </td>\n                </tr>\n                { indicators }\n            </React.Fragment>\n            );\n    })\n);\n\n@inject('rootStore')\n@observer\nclass IPTTTableBody extends React.Component {\n    get noIndicatorsForFrequency() {\n        return false;\n    }\n    get tableContent() {\n        if (this.props.rootStore.loading || !this.props.rootStore.initialized) {\n            return <Loading />;\n        } else if (this.noIndicatorsForFrequency) {\n            return <NoIndicatorsForFrequency />;\n        } else if (this.props.rootStore.filtersApplied && this.props.rootStore.report\n                   && this.props.rootStore.report.length == 0) {\n            return <NoIndicatorsForFilters />;\n        } else {\n            return this.props.rootStore.report.map(\n                        (level, count) => <LevelRow level={ level } key={ count } />\n                        );\n        }\n    }\n    \n    render() {\n            return (\n                <tbody>\n                    { this.tableContent }\n                </tbody>\n            );\n    }\n}\n\nconst IPTTTable = () => {\n    return (\n        <table className=\"table table-sm table-bordered table-hover table__iptt\" id=\"iptt_table\">\n            <IPTTTableHead />\n            <IPTTTableBody />\n        </table>\n        );\n}\nexport default IPTTTable;","/**\n * entry point for the iptt_report webpack bundle\n */\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport createRouter from 'router5';\nimport browserPlugin from 'router5-plugin-browser';\nimport { Provider, inject } from 'mobx-react';\nimport { RootStore, ReportAPI } from './models';\nimport { IPTTReportApp } from './components/main';\n\n//testing:\nimport { contextFixture, reportData } from './fixtures';\n\n\nconst labels = jsContext.labels;\nconst reportAPI = new ReportAPI('/indicators/iptt_report_data/');\nconst rootStore = new RootStore(jsContext, reportAPI);\n\nconst routes = [\n    {name: 'iptt', path: '/:programId<\\\\d+>/:reportType/?frequency&timeperiods&targetperiods&timeframe&numrecenteperiods&start&end&start_period&end_period&levels&sites&types&sectors&indicators&tiers&groupby'}\n];\n\nconst router = createRouter(routes);\n\nrouter.usePlugin(browserPlugin({useHash: false, base: '/indicators/iptt_report'}));\nrouter.subscribe(rootStore.updateRoute);\nrouter.start();\n\nrootStore.init(router);\n\n\nReactDOM.render(<Provider rootStore={ rootStore }\n                          labels={ labels } >\n                    <IPTTReportApp />    \n                </Provider>,\n                document.querySelector('#id_div_content'));","import React from 'react';\nimport { inject, observer } from 'mobx-react';\nimport Popover from 'react-simple-popover';\n\n@inject('labels', 'rootStore')\nclass PinPopover extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            reportName: '',\n            sending: false,\n            sent: false\n        };\n    }\n    handleChange = (e) => {\n        this.setState({reportName: e.target.value});\n    }\n    isDisabled = () => {\n        return !this.props.rootStore.pinData || !this.state.reportName;\n    }\n    handleClick = () => {\n        //send this.props.rootStore.pinUrl as data to this.props.labels.pin.creatUrl\n        //with data \"name\" as this.state.reportName\n        this.setState({sending: true});\n        $.ajax({\n            type: \"POST\",\n            url: this.props.labels.pin.createUrl,\n            data: {name: this.state.reportName, ...this.props.rootStore.pinData },\n            success: () => {this.setState({sending:false, sent: true}); },\n            error: () => {console.log(\"AJAX ERROR\");}\n        });\n    }\n    render() {\n        return (\n            <React.Fragment>\n                { this.state.sent\n                    ? <div className=\"form-group\">\n                        <p>\n                            <span>{ this.props.labels.pin.successMsg }</span>\n                        </p>\n                        <p>\n                           <a href={ this.props.rootStore.programPageUrl }>\n                                { this.props.labels.pin.successLink }\n                           </a>\n                        </p>\n                      </div>\n                    : <React.Fragment>\n                        <div className=\"form-group\">\n                            <label className=\"text-uppercase\">\n                               { this.props.labels.pin.reportName }\n                            </label>\n                            <input type=\"text\" className=\"form-control\"\n                                 value={ this.state.reportName }\n                                 onChange={ this.handleChange }\n                                 disabled={ this.state.sending }/>\n                        </div>\n                        { this.state.sending\n                            ? <div className=\"btn btn-outline-primary\" disabled>\n                                <img src='/static/img/ajax-loader.gif' />&nbsp;\n                                    { this.props.labels.loading }\n                              </div>\n                            : <button type=\"button\"\n                                  onClick={ this.handleClick }\n                                  disabled={ this.isDisabled() }\n                                  className=\"btn btn-primary\">\n                                      { this.props.labels.pin.submitButton }\n                              </button>\n                        }\n                        </React.Fragment>\n                        \n                }\n            </React.Fragment>\n        );\n    }\n}\n\n@inject('labels')\nexport class PinButton extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            open: false\n        };\n    }\n    \n    handleClick(e) {\n        this.setState({open: !this.state.open});\n    }\n    \n    handleClose(e) {\n        this.setState({open: false});\n    }\n    \n    render() {\n        return (\n            <React.Fragment>\n                <div\n                    className=\"btn btn-sm btn-secondary\"\n                    ref=\"target\"\n                    onClick={ this.handleClick.bind(this) }>\n                <i className=\"fas fa-thumbtack\"></i> { this.props.labels.pin.buttonLabel }\n                </div>\n                <Popover\n                    placement='bottom'\n                    style={ {width: 'auto' } }\n                    target={ this.refs.target }\n                    show={ this.state.open }\n                    onHide={ this.handleClose.bind(this) } >\n                    <PinPopover />\n                </Popover>\n            </React.Fragment>\n        );\n    }\n}\n\n\n@inject('labels', 'rootStore')\n@observer\nclass ExcelPopover extends React.Component {\n    getCurrent = () => {\n        if (this.props.rootStore.currentExcelURL) {\n            window.location=this.props.rootStore.currentExcelURL;\n        }\n    }\n    \n    getAll = () => {\n        if (this.props.rootStore.allExcelURL) {\n            window.location=this.props.rootStore.allExcelURL;\n        }\n    }\n    render() {\n        return (\n            <div className=\"container-fluid\">\n                <div className=\"row mt-1 mb-2\">\n                    <div className=\"btn btn-primary btn-block\"\n                         onClick={ this.getCurrent }>\n                        { this.props.labels.excel.buttonCurrent }\n                    </div>\n                </div>\n                <div className=\"row mt-2 mb-1\">\n                    <div className=\"btn btn-primary btn-block\"\n                         onClick={ this.getAll }>\n                         { this.props.labels.excel.buttonAll }\n                    </div>\n                </div>\n            </div>\n        );\n    }\n}\n\n@inject('labels', 'rootStore')\n@observer\nexport class ExcelButton extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            open: false\n        };\n    }\n    \n    handleClick = () => {\n        if (this.props.rootStore.isTVA) {\n            this.setState({open: !this.state.open});\n        } else if (this.props.rootStore.currentExcelURL) {\n            window.location=this.props.rootStore.currentExcelURL;\n        }\n    }\n    \n    handleClose(e) {\n        this.setState({open: false});\n    }\n    render() {\n        return (\n            <React.Fragment>\n                <div className=\"btn btn-sm btn-secondary\"\n                     ref=\"target\"\n                     onClick={this.handleClick.bind(this) }>\n                     <i className=\"fas fa-download\"></i> { this.props.labels.excel.buttonMain }\n                     </div>\n                     <Popover\n                        placement=\"bottom\"\n                        containerStyle={ {paddingRight: '10px'} }\n                        style={ {width: 'auto' } }\n                        target={ this.refs.target }\n                        show={ this.state.open }\n                        onHide={ this.handleClose.bind(this) } >\n                        <ExcelPopover />\n                      </Popover>\n            </React.Fragment>\n        );\n    }\n}\n\nexport const ClearButton = inject('labels', 'rootStore')(\n    ({labels, rootStore}) => {\n        return (\n            <div className=\"btn btn-primary btn-block\"\n                onClick={ rootStore.clearFilters }>\n                    { labels.resetButton }\n            </div>\n        )\n    }\n);","import React from 'react';\nimport { inject, observer } from 'mobx-react';\nimport { computed } from 'mobx';\nimport Select from 'react-select';\nimport ReactMultiSelectCheckboxes from 'react-multiselect-checkboxes';\nimport { uniqueId } from '../../../formUtils';\n\nconst IPTTMultiSelectWrapper = (props) => {\n    return <div className=\"form-row mb-2 iptt-react-select-row\">\n                <label htmlFor={props.id} className=\"col-form-label text-uppercase\">\n                    { props.label }\n                </label>\n                { props.children }\n            </div>;\n}\n\n\n/**\n * styling element to replace OptGroup headings in react multiselect checkbox widgets - used for\n * LevelSelect (no optgroup label shown for the tiers group, no checkbox by other labels)\n */\nconst GroupHeading = (props) => {\n    if (props.children == '') {\n        return <div></div>;\n    } else {\n        return (\n            <React.Fragment>\n                <hr style={{ margin: '3px 0px 0px 0px' }} />\n                <div style={{ textTransform: 'uppercase',\n                              paddingLeft: '4px',\n                              marginBottom: '2px'}}>\n                    { props.children }\n                </div>\n            </React.Fragment>\n            );\n    }\n}\n\n\nexport class IPTTMultiselectCheckboxWrapper extends React.Component {\n    constructor(props) {\n        super(props);\n        this._id = uniqueId('multiselect');\n    }\n    get options() {\n        return [];\n    }\n    get value() {\n        return {value: null, label: ''};\n    }\n    get label() {\n        return '';\n    }\n    getProps = () => {\n        if (this.options.length == 0) {\n            return {\n                getDropdownButtonLabel: () => this.props.labels.noOptionsSelect,\n                isDisabled: true,\n                menuIsOpen: false,\n                options: [],\n                id: this._id,\n            };\n        }\n        return {\n            isMulti: true,\n            id: this._id,\n            options: this.options,\n            getDropdownButtonLabel: (_ref) => {\n                if (!_ref.value) {\n                    return this.props.labels.emptySelect;\n                }\n                if (Array.isArray(_ref.value)) {\n                    if (_ref.value.length == 0) {\n                        return this.props.labels.emptySelect;\n                    }\n                    if (_ref.value.length == 1) {\n                        return _ref.value[0].label;\n                    }\n                    return \"\".concat(_ref.value.length, \" \", this.props.labels.selected);\n                }\n                return _ref.value.label;\n            }\n        };       \n    }\n    getBaseStyles = () => ({\n        dropdownButton: base => this.options.length == 0\n                                ? { ...base, backgroundColor: '#E5E6E8', background: '' }\n                                : base,\n        option: (provided, state) => ({\n                ...provided,\n                padding: '1px 12px',\n                display: 'inline-block'\n            }),\n        container: (provided, state) => ({\n                ...provided,\n                backgroundColor: '#f5f5f5'\n            }),\n    });\n    \n    render() {\n        const formatOptionLabel = (props) => {\n            return <div style={{ display: \"inline-block\" , float: \"right\", width: \"90%\"}}>{props.label}</div>;\n        }\n        return <IPTTMultiSelectWrapper id={ this._id} label={ this.label }>\n                    <ReactMultiSelectCheckboxes\n                            styles={ this.getBaseStyles() }\n                            formatOptionLabel={ formatOptionLabel }\n                            components={{ GroupHeading }}\n                            value={ this.value }\n                            { ...this.getProps() }\n                            onChange={ this.onChange } />\n                </IPTTMultiSelectWrapper>;\n    }\n}\n\n\n\nexport const IPTTSelectWrapper = (props) => {\n    return <div className=\"form-row mb-3\">\n                <label htmlFor={ props.id } className=\"col-form-label text-uppercase\">\n                    { props.label }\n                </label>\n                { props.children }\n            </div>;\n}\n\nexport class IPTTSelect extends React.Component {\n    constructor(props) {\n        super(props);\n        this._id = uniqueId('react-select');\n    }\n    render() {\n        return (\n            <IPTTSelectWrapper id={ this._id } label={ this.label }>\n                <Select {...this.selectOptions} id={ this._id } className=\"iptt-react-select\" />\n            </IPTTSelectWrapper>\n        );\n    }\n}\n\n\n@inject('rootStore')\n@observer\nexport class DateSelect extends React.Component {\n    constructor(props) {\n        super(props);\n        this._id = uniqueId('date-select');\n    }\n    @computed get options() {\n        if (this.props.rootStore.selectedFrequencyId == 7) {\n            return Object.entries(this.props.rootStore.periodOptions).map(\n                ([optgroupLabel, options], index) => {\n                    return <optgroup label={optgroupLabel} key={index}>\n                        {options.map(\n                            (option) => <option value={option.value} key={option.value}>{option.label}</option>\n                        )}\n                    </optgroup>;\n                }\n            );\n        } else {\n            return this.props.rootStore.periodOptions.map(\n                (option) => <option value={option.value} key={option.value}>{option.label}</option>\n            );\n        }\n    }\n    render() {\n        return <IPTTSelectWrapper id={ this._id }label={ this.props.label }>\n                    <select className=\"form-control\"\n                            id={ this._id }\n                            value={ this.props.value }\n                            onChange={ this.props.onChange }\n                            disabled={ this.props.rootStore.selectedFrequencyId == 2 || this.props.rootStore.selectedFrequencyId == 1 }>\n                        { this.options }\n                    </select>\n                </IPTTSelectWrapper>;\n    }\n}"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAIA;AAAA;AAKA;AAIA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AADA;AAKA;AAAA;AACA;AAAA;AAAA;AACA;AADA;AAEA;AAAA;AAIA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAMA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AAAA;AAEA;AAIA;AANA;AACA;AADA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAMA;;;;;;;;;;;;;AACA;AAAA;AAAA;;;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAHA;AAKA;;;;AARA;AAWA;;;;;AAMA;;;;;;;;;;;;;AACA;AAAA;AACA;;;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAHA;AAKA;;;;AATA;AAYA;;;;;AAIA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAFA;AAGA;AAGA;;;;;AAIA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAFA;AAGA;AAGA;;;;;;AAOA;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAMA;AAAA;AAKA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAMA;AAAA;AAKA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAHA;AAOA;;;;AA9CA;AAiDA;;;;;;AAOA;;;;;;;;;;;;;;;;;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAIA;AAAA;AACA;AAAA;AAIA;;;;AAlBA;AAqBA;;;;;;;AAQA;;;;;;;;;;;;;;;;;;AA2BA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAzCA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AADA;AAEA;AACA;AADA;AAGA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;;;;AAzBA;AA8CA;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;AACA;;;;;;AAAA;AACA;AACA;;;AACA;AACA;AACA;;;AACA;AACA;AACA;;;;AAZA;AAkBA;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;AACA;;;;;;AAAA;AACA;AACA;;;AACA;AACA;AACA;;;AACA;AACA;AACA;;;;AAZA;AAiBA;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;AACA;;;;;;AAAA;AACA;AACA;;;AACA;AACA;AACA;;;AACA;AACA;AACA;;;;AAZA;AAkBA;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;AACA;;;;;;AAAA;AACA;AACA;;;AACA;AACA;AACA;;;AACA;AACA;AACA;;;;AAZA;AAgBA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAQA;AAAA;AAAA;AAQA;AAGA;;;;;;;;;;;;AC5SA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAZA;AApCA;AAoDA;AAEA;AACA;AACA;AACA;AACA;AAMA;AAMA;AAMA;AAeA;AAmBA;AAuBA;AA5EA;AAJA;AAkLA;AACA;AACA;AACA;AACA;AAMA;AAMA;AAMA;AAUA;AAcA;AAkBA;AA7DA;AAJA;AAvOA;AAwXA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAZA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAZA;AAjBA;AADA;;;;;;;;;;;;ACzXA;AAAA;AAAA;;;AAIA;AAEA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;ACTA;AAAA;AAAA;;;;;;;;;;;AAYA;AACA;AACA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChBA;;;;AAKA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAJA;AAAA;AAAA;AAMA;AACA;AACA;AACA;AAHA;AAKA;AACA;AAZA;AACA;AADA;AAAA;AAeA;;;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAEA;AACA;;;AAAA;AACA;AACA;;;AAEA;AACA;AACA;;;;AAnBA;AAuBA;;;AAKA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AAAA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AACA;;;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;;AA3EA;;;;;AAAA;;AACA;;;;;AAAA;;AACA;;;;;AAAA;;AAkDA;AA4BA;;;AAUA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;;;AAGA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA,mBAEA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA,mBAEA;AACA;AAAA;AACA;;;AAEA;AACA;AAAA;AAAA;AACA;;;AAEA;AACA;AAAA;AAAA;AACA;;;AAEA;AACA;AAIA;;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AADA;AAAA;AAGA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AADA;AAAA;AAGA;;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AADA;AAAA;AAFA;AAAA;AAMA;AACA;;;;AArOA;;;;;AAAA;;AACA;;;;;AAAA;;AACA;;;;;AAAA;;AACA;;;;;AAAA;;AACA;;;;;AAAA;AACA;AACA;AAFA;;AAgCA;AACA;AAoMA;;;AACA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;;;;;;AAIA;AAAA;AAAA;AA0BA;AAAA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAYA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAvDA;AAyDA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AA/DA;AAiGA;AAAA;AAEA;AAEA;AArGA;AACA;AADA;AAkNA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AA7NA;AA+NA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAnRA;AAwdA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AADA;AAEA;AACA;AACA;AAneA;AAueA;AACA;AAAA;AACA;AACA;AA1eA;AA4eA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AApfA;AA0gBA;AACA;AAAA;AACA;AACA;AA7gBA;AA+gBA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAphBA;AAshBA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AA3hBA;AA6hBA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAhiBA;AAkiBA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAriBA;AAuiBA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AA1iBA;AA4iBA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AA/iBA;AAijBA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAxjBA;AACA;AACA;AACA;AAKA;AACA;AApCA;AAAA;AAAA;AAkIA;AACA;AACA;AACA;AACA;AACA;AAvIA;AAAA;AAAA;AA+KA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAtLA;AAAA;AAAA;AAyLA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAnMA;AAAA;AAAA;AAsMA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AA7MA;AAAA;AAAA;AA+MA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAtNA;AAAA;AAAA;AAyNA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAhOA;AAAA;AAAA;AAkOA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAzOA;AAAA;AA8SA;AAEA;AAhTA;AAmTA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AArUA;AAAA;AAqVA;AArVA;AAwVA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzWA;AAAA;AAAA;AA4WA;AACA;AA7WA;AAAA;AAAA;AAgXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AA3XA;AAAA;AAsZA;AAtZA;AAyZA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAtaA;AAAA;AAAA;AAyaA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAtbA;AAAA;AAAA;AA2FA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AArGA;AAAA;AAAA;AAwGA;AACA;AAzGA;AAAA;AAAA;AA4GA;AACA;AACA;AACA;AACA;AACA;AAjHA;AAAA;AAAA;AAoHA;AACA;AACA;AACA;AACA;AACA;AAzHA;AAAA;A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","sourceRoot":""}