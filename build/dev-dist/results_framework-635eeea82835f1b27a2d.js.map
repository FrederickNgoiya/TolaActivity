{"version":3,"file":"results_framework-635eeea82835f1b27a2d.js","sources":["webpack:///./js/pages/results_framework/components/leveltier_picker.js","webpack:///./js/components/helpPopover.js","webpack:///./js/pages/results_framework/components/level_cards.js","webpack:///./js/components/selectWidgets.js","webpack:///./js/pages/results_framework/models.js","webpack:///./js/formUtils.js","webpack:///./js/pages/results_framework/index.js","webpack:///./js/api.js","webpack:///./js/components/indicatorModalComponents.js","webpack:///./js/eventbus.js","webpack:///./js/pages/results_framework/components/level_list.js","webpack:///./js/constants.js"],"sourcesContent":["import React from 'react';\nimport { observer, inject } from \"mobx-react\";\nimport { toJS } from \"mobx\";\n\nimport Select from 'react-select';\n\n@inject('rootStore')\n@observer\nclass Picker extends React.Component {\n    handleChange = selectedTemplate => {\n        this.props.rootStore.levelStore.changeTierSet(selectedTemplate.value);\n    };\n\n    componentDidUpdate() {\n        // Enable popovers after update (they break otherwise)\n        $('*[data-toggle=\"popover\"]').popover({\n            html: true\n        });\n    }\n\n    render() {\n        let helpIcon = null;\n        if (this.props.rootStore.uiStore.tierLockStatus == \"locked\"){\n\n            helpIcon = <a href=\"#\"\n                tabIndex=\"0\"\n                data-toggle=\"popover\"\n                data-trigger=\"focus\"\n                data-html=\"true\"\n                data-content={gettext('<span class=\"text-danger\"><strong>The results framework template cannot be changed after levels are saved.</strong></span> To change templates, all saved levels first must be deleted.  A level can be deleted when it has no sub-levels and no linked indicators.')}>\n                <i className=\"far fa-question-circle\"></i></a>\n        }\n        else if (this.props.rootStore.uiStore.tierLockStatus == \"primed\"){\n            helpIcon = <a href=\"#\"\n                tabIndex=\"0\"\n                data-toggle=\"popover\"\n                data-trigger=\"focus\"\n                data-html=\"true\"\n                data-content={gettext('<span class=\"text-danger\"><strong>Choose your results framework template carefully!</strong></span> Once you begin building your framework, it will not be possible to change templates without first deleting all saved levels.')}>\n                <i className=\"far fa-question-circle\"></i></a>\n        }\n\n\n        const tierTemplates = this.props.rootStore.levelStore.tierTemplates;\n\n        const options = Object.keys(tierTemplates).sort().map(key => {\n            return {value:key, label:tierTemplates[key]['name']};\n        });\n\n        const selectedOption = {value:this.props.rootStore.levelStore.chosenTierSetKey, label: this.props.rootStore.levelStore.chosenTierSetName};\n\n        let classes = \"leveltier-picker__selectbox \";\n        classes += this.props.rootStore.uiStore.tierLockStatus == \"locked\" ? \"leveltier-picker__selectbox--disabled\" : \"\";\n\n        return (\n              <div className={classes}>\n                  <div className=\"form-group\">\n                    <label>{gettext('Results framework template')}</label>&nbsp;<small>{helpIcon}</small>\n                    <Select\n                        options={options}\n                        value={selectedOption}\n                        isDisabled={this.props.rootStore.uiStore.tierLockStatus == \"locked\" ? true : false}\n                        onChange={this.handleChange}\n                    />\n                </div>\n            </div>\n        )\n    }\n}\n\nclass LevelTier extends React.Component {\n\n    render() {\n        return (\n            <div className={'leveltier leveltier--level-' + this.props.tierLevel}>{this.props.tierName} </div>\n    )}\n}\n\n@inject('rootStore')\n@observer\nclass LevelTierList extends React.Component{\n\n    render() {\n        let apply_button = null\n        if (this.props.rootStore.levelStore.levels.length == 0) {\n            apply_button =\n                <button\n                    className=\"leveltier-button btn btn-primary btn-block\"\n                    onClick={this.props.rootStore.levelStore.createFirstLevel}>\n                    {/* #Translators: this refers to an imperative verb on a button (\"Apply filters\")*/}\n                    {gettext(\"Apply\")}\n                </button>\n        }\n\n        return (\n            <React.Fragment>\n                <div id=\"leveltier-list\" className=\"leveltier-list\">\n                    {\n                        this.props.rootStore.levelStore.chosenTierSet.length > 0 ?\n                            this.props.rootStore.levelStore.chosenTierSet.map((tier, index) => {\n                                return <LevelTier key={index} tierLevel={index} tierName={tier}/>\n                            })\n                            : null\n                    }\n\n\n                </div>\n                {\n                    apply_button ?\n                        <div className=\"leveltier-list__actions\">\n                            {apply_button}\n                        </div>\n                    : null\n                }\n            </React.Fragment>\n        )\n    }\n}\n\nexport const LevelTierPicker = inject(\"rootStore\")(observer(function (props) {\n\n    return (\n        <div id=\"leveltier-picker\" className=\"leveltier-picker\">\n            <Picker />\n            <LevelTierList />\n        </div>\n        /*<div id=\"alerts2\" style={{minHeight:\"50px\", minWidth:\"50px\", backgroundColor:\"red\"}}></div>*/\n\n    )\n}));\n","import React from 'react'\nimport ReactDOM from 'react-dom';\n\nexport default class HelpPopover extends React.Component {\n    constructor(props) {\n        super(props)\n        this.content = props.content;\n        this.placement = props.placement || null;\n    }\n\n    render() {\n        return (\n            <a\n                tabIndex=\"0\"\n                data-toggle=\"popover\"\n                data-trigger=\"focus\"\n                data-html=\"true\"\n                data-placement={this.placement}\n                data-content={this.content}>\n            <i className=\"far fa-question-circle\"></i></a>\n        )\n    }\n}\n\n\nexport class BootstrapPopoverButton extends React.Component {\n    popoverName = 'base';\n\n    componentDidMount = () => {\n        // make a cancelable (class method) function so clicking out of the popover will close it:\n        this.bodyClickHandler = (ev) => {\n            if ($(`#${this.popoverName}_popover_content`).parent().find($(ev.target)).length == 0) {\n                $(this.refs.target).popover('hide');\n            }\n        }\n        const popoverOpenHandler = () => {\n            // first make it so any click outside of the popover will hide it:\n            $('body').on('click', this.bodyClickHandler);\n            // update position (it's had content loaded):\n            $(this.refs.target).popover('update')\n                //when it hides destroy the body clickhandler:\n                .on('hide.bs.popover', () => {$('body').off('click', this.bodyClickHandler);});\n        };\n        const shownFn = (ev) => {\n            ReactDOM.render(\n                this.getPopoverContent(),\n                document.querySelector(`#${this.popoverName}_popover_content`),\n                popoverOpenHandler\n            );\n        };\n        $(this.refs.target).popover({\n            content: `<div id=\"${this.popoverName}_popover_content\"></div>`,\n            html: true,\n            placement: 'bottom'\n        }).on('shown.bs.popover', shownFn);\n    }\n    \n    getPopoverContent = () => {\n        throw new Error('not implemented');\n    }\n}","import React from 'react';\nimport classNames from 'classnames';\nimport { observer, inject } from \"mobx-react\"\nimport { toJS, extendObservable, action } from 'mobx';\nimport { library } from '@fortawesome/fontawesome-svg-core'\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { faCaretRight, faCaretDown, faArrowsAlt } from '@fortawesome/free-solid-svg-icons'\nimport { SingleReactSelect } from \"../../../components/selectWidgets\";\nimport { AddIndicatorButton, UpdateIndicatorButton } from '../../../components/indicatorModalComponents';\nimport {sortableContainer, sortableElement, sortableHandle} from 'react-sortable-hoc';\nimport HelpPopover from \"../../../components/helpPopover\";\n\n\n\nlibrary.add(faCaretDown, faCaretRight, faArrowsAlt);\n\nexport class LevelTitle extends React.Component {\n\n    render() {\n        return (\n            <h3 className={'level-title ' + this.props.classes}>\n                {this.props.tierName}\n                {/*if we don't check whether there is an ontology, there ill be an extra\n                space before the colon */}\n                {this.props.ontologyLabel ? \" \" + this.props.ontologyLabel : null}\n            </h3>\n        )\n    }\n}\n\n@inject('rootStore')\n@observer\nexport class LevelCardCollapsed extends React.Component {\n\n    deleteLevel = () => {\n        const levelTitle = this.props.levelProps.tierName + \" \" + this.props.levelProps.ontologyLabel;\n        create_no_rationale_changeset_notice({\n            /* # Translators:  This is a confirmation prompt that is triggered by clicking on a delete button. The code is a reference to the specific item being deleted.  Only one item can be deleted at a time. */\n            message_text: `Are you sure you want to delete ${levelTitle}?`,\n            on_submit: () => this.props.rootStore.levelStore.deleteLevelFromDB(this.props.level.id)});\n\n    };\n\n    editLevel = () => {\n        this.props.rootStore.uiStore.editCard(this.props.level.id)\n    };\n\n    componentDidMount() {\n        // Enable popovers after update (they break otherwise)\n        $('*[data-toggle=\"popover\"]').popover({\n            html: true\n        });\n    }\n\n    buildIPTTUrl = (indicator_ids) => {\n        let url = `/indicators/iptt_report/${this.props.rootStore.levelStore.program_id}/timeperiods/?frequency=3&start=0&end=999`;\n        indicator_ids.forEach( i => url += \"&indicators=\"+i);\n        return url\n    };\n\n    render(){\n        // the level card shouldn't be displayed if it's parent level is not expandoed (except\n        // if the level is the top level one).\n        if (this.props.rootStore.uiStore.hasVisibleChildren.indexOf(this.props.level.parent) < 0 && this.props.level.parent != null){\n            return null;\n        }\n\n        // Prepare the indicator links for the indicator popover\n\n        let allIndicatorLinks = [];\n\n        // Get indicator ids linked to this level and create a hyperlink for a filtered IPTT.\n        let sameLevelIndicatorIds = this.props.levelProps.indicators.map( i => i.id);\n        if (sameLevelIndicatorIds.length > 0) {\n            const linkText = `All indicators linked to ${this.props.levelProps.tierName} ${this.props.levelProps.ontologyLabel}`\n            allIndicatorLinks.push(`<a href=${this.buildIPTTUrl(sameLevelIndicatorIds)}>${linkText}</a>`);\n        }\n\n        // Get indicator ids linked to the descendants of this level, add the indicator ids identified\n        // above, and create a hyperlink for a filtered IPTT.  Only do this if the level has sublevels.\n        if (this.props.levelProps.tierName != this.props.rootStore.levelStore.chosenTierSet.slice(-1)[0]) {\n            let descendantIndicatorIds = this.props.levelProps.descendantIndicatorIds;\n            descendantIndicatorIds = descendantIndicatorIds.concat(sameLevelIndicatorIds);\n            if (descendantIndicatorIds.length > 0) {\n                const linkText = `All indicators linked to ${this.props.levelProps.tierName} ${this.props.levelProps.ontologyLabel} and sub-levels`;\n                allIndicatorLinks.unshift(`<a href=${this.buildIPTTUrl(descendantIndicatorIds)}>${linkText}</a>`);\n            }\n        }\n\n        // Create IPTT hyperlinks for each individual indicator linked to this level\n        let individualLinks = this.props.levelProps.indicators.map( (indicator, index) => {\n            const ontologyLabel = this.props.levelProps.ontologyLabel + String.fromCharCode(97+index) + \": \";\n            return `<li class=\"nav-item\"><a href=${this.buildIPTTUrl([indicator.id])}>${ontologyLabel}${indicator.name}</a></li>`;\n        });\n        allIndicatorLinks = allIndicatorLinks.concat(individualLinks);\n\n\n        let indicatorMarkup = `<ul class=\"nav flex-column\">${allIndicatorLinks.join(\"<br>\")}</ul>`;\n        const iCount = this.props.levelProps.indicators.length;\n        /* # Translators: This is a count of indicators associated with another object */\n        const indicatorCountText = interpolate(ngettext(\"%s indicator\", \"%s indicators\", iCount), [iCount]);\n\n        // The expando caret is only applied to levels that:\n        // 1. Aren't at the end of the leveltier hierarchy\n        // 2. Actually have children\n        let expando = null;\n        if (this.props.levelProps.tierName != toJS(this.props.rootStore.levelStore.chosenTierSet.slice(-1)[0]) &&\n            this.props.rootStore.levelStore.levels.filter( l => l.parent == this.props.level.id).length > 0){\n            expando = <FontAwesomeIcon className=\"text-action\" icon={this.props.rootStore.uiStore.hasVisibleChildren.indexOf(this.props.level.id) >= 0 ? 'caret-down' : 'caret-right'} />\n        }\n\n        return (\n            <div className=\"level-card level-card--collapsed\" id={`level-card-${this.props.level.id}`}>\n                <div\n                    className={expando ? \"level-card__toggle\": \"\"}\n                    onClick={(e) => this.props.rootStore.uiStore.updateVisibleChildren(this.props.level.id)}>\n                    {expando}\n                    <span className=\"level-card--collapsed__name\">\n                        <LevelTitle\n                            tierName={this.props.levelProps.tierName}\n                            ontologyLabel={this.props.levelProps.ontologyLabel}\n                            classes=\"level-title--collapsed\"\n                        />\n                        &nbsp;{this.props.level.name}\n                    </span>\n                </div>\n                <div className=\"level-card--collapsed__actions\">\n                    <div className=\"actions__top btn-row\">\n                        { this.props.levelProps.canDelete &&\n                            <button\n                                className=\"btn btn-sm btn-link btn-danger\"\n                                onClick={this.deleteLevel}>\n                                <i className=\"fas fa-trash-alt\"></i>{gettext(\"Delete\")}\n                            </button>\n                        }\n                        {this.props.levelProps.canEdit &&\n                            <button className=\"btn btn-sm btn-link btn-text edit-button\" onClick={this.editLevel}>\n                                <i className=\"fas fa-edit\"/>{gettext(\"Edit\")}\n                            </button>\n                        }\n                    </div>\n                    <div className=\"actions__bottom\">\n                        <button\n                            className=\"btn btn-sm btn-link no-bold\"\n                            data-toggle=\"popover\"\n                            data-trigger=\"focus\"\n                            data-placement=\"bottom\"\n                            data-html=\"true\"\n                            title=\"Track indicator performance\"\n                            data-content={indicatorMarkup}\n                            disabled={allIndicatorLinks.length == 0}>\n                            {indicatorCountText}\n                        </button>\n                    </div>\n                </div>\n            </div>\n        )\n    }\n}\n\n\n@inject('rootStore')\n@observer\nexport class LevelCardExpanded extends React.Component {\n    constructor(props){\n        super(props);\n        this.submitType = \"saveOnly\";\n        this.indicatorWasReordered = false;\n\n        // These 'base' vars will allow us to save orignalish data so we know whether to prompt users if they hit cancel.\n        // baseIndicators will need to be updated on indicator changes other than reordering since we don't\n        // want to warn for e.g. indicator creation, since users can't do anything about that.\n        this.baseLevelString = JSON.stringify([props.level.name, props.level.assumptions]);\n        this.baseIndicators = this.props.levelProps.indicators.slice().map( i => toJS(i));\n\n        extendObservable(this, {\n            name: props.level.name,\n            assumptions: props.level.assumptions,\n            indicators: props.levelProps.indicators.sort((a, b) => a.level_order - b.level_order),\n\n            get dataHasChanged () {\n                const baseData = this.baseLevelString + JSON.stringify(this.baseIndicators.sort( (a, b) => a.id - b.id));\n                const currentData = JSON.stringify([this.name, this.assumptions]) + JSON.stringify(toJS(this.indicators).sort( (a, b) => a.id - b.id));\n                return currentData != baseData;\n            },\n\n            addIndicator (data) {\n                this.indicators.push(data);\n                this.baseIndicators.push(data)\n            },\n\n            deleteIndicator (indicatorId) {\n                this.indicators = this.indicators.filter( i => i.id != indicatorId);\n                this.indicators.forEach( (indicator, index) => indicator.level_order = index);\n                this.baseIndicators = this.baseIndicators.filter( i => i.id != indicatorId);\n                this.baseIndicators.forEach( (indicator, index) => indicator.level_order = index);\n            },\n\n            updateIndicatorName (indicatorId, newName) {\n                this.indicators.find( i => i.id == indicatorId).name = newName;\n                this.baseIndicators.find( i => i.id == indicatorId).name = newName\n            }\n\n        }, {\n            addIndicator: action,\n            deleteIndicator: action,\n            updateIndicatorName: action\n        });\n        console.log('constructor indicators', toJS(this.indicators))\n    }\n\n    onDragEnd = ({oldIndex, newIndex}) => {\n        this.indicatorWasReordered = true;\n        const indicatorId = this.indicators[oldIndex].id;\n        const fakeChangeObj = {value: newIndex + 1, name: newIndex + 1};\n        this.changeIndicatorOrder(indicatorId, fakeChangeObj)\n    };\n\n    // Updates the indicator order, resets level_order as necessary, sets updated data flag.\n    changeIndicatorOrder = (indicatorId, changeObj) => {\n        let oldIndex = this.indicators.find( i => i.id == indicatorId).level_order;\n        let newIndex = changeObj.value - 1;\n        let tempIndicators = this.indicators.slice();\n        tempIndicators.splice(newIndex, 0, tempIndicators.splice(oldIndex, 1)[0]);\n        tempIndicators.forEach( (indicator, index) => indicator.level_order = index);\n        this.indicators.replace(tempIndicators)\n        this.props.rootStore.uiStore.activeCardNeedsConfirm = this.dataHasChanged;\n        this.indicatorWasReordered = true;\n    };\n\n    /*\n    Using this allows us to use the same submit function for all three buttons.  Shame the function has to\n    be passed all the way down to the button to work.\n     */\n    updateSubmitType = (newType) => {\n        this.submitType = newType;\n    };\n\n    componentDidUpdate() {\n        // Enable popovers after update.  This is needed for the help popover in the indicator list section.\n        // Without this, the popover doesnt' pop.\n        $('*[data-toggle=\"popover\"]').popover({\n            html: true\n        });\n    }\n\n    componentDidMount() {\n        // Enable popovers after load (they break otherwise)\n        $('*[data-toggle=\"popover\"]').popover({\n            html: true\n        });\n\n        // Handle indicator creation.  Need to update rootStore and component store so if you close and reopen the card, you still see the new indicator\n        $('#indicator_modal_div').on('created.tola.indicator.save', (e, params) => {\n            const indicatorData = {\n                id: params.indicatorId,\n                name: params.indicatorName,\n                level: this.props.level.id,\n                level_order: this.indicators.length\n            };\n            this.props.rootStore.levelStore.addIndicatorToStore(indicatorData)\n            this.addIndicator(indicatorData)\n\n        });\n\n        // Handle indicator deletion.  Need to update rootStore and component store so if you close and reopen the card, you still see the new indicator\n        $('#indicator_modal_div').on('deleted.tola.indicator.save', (e, params) => {\n            this.props.rootStore.levelStore.deleteIndicatorFromStore(params.indicatorId);\n            this.deleteIndicator(params.indicatorId)\n\n        });\n\n        // Handle indicator update.  Need to update rootStore and component store so if you close and reopen the card, you still see the new indicator\n        $('#indicator_modal_div').on('updated.tola.indicator.save', (e, params) => {\n            console.log('params level, props.level, rootstore active card', params.levelId, this.props.level.id, this.props.rootStore.uiStore.activeCard)\n            // This.props.level.id doesn't seem to be updating here, perhaps because the event is attaching a jquery listener\n            // So rootstore props are bing used instead of passed in ones.\n            const currentCardId = this.props.rootStore.uiStore.activeCard;\n            if (params.levelId != currentCardId){\n                // Only add the indicator to another level if it wasn't blanked out\n                console.group()\n                console.log('updated indicator params', params)\n                console.log('indicators before', this.props.rootStore.levelStore.indicators.forEach( i => console.log('i', toJS(i))))\n                console.log('this.indicators count', this.indicators.length);\n                console.groupEnd()\n                if (params.levelId){\n                    this.props.rootStore.levelStore.moveIndicatorInStore(params.indicatorId, params.levelId)\n                }\n                this.deleteIndicator(params.indicatorId);\n                console.log('indicators after', this.props.rootStore.levelStore.indicators.forEach( i => console.log('i2', toJS(i))))\n            }\n            else {\n                console.log('params ind id, params name, current name', params.indicatorId, params.indicatorName, this.props.level.name);\n                this.indicators.find( i => i.id == params.indicatorId).name = params.indicatorName;\n                this.props.rootStore.levelStore.updateIndicatorNameInStore(params.indicatorId, params.indicatorName);\n            }\n\n            // Need to remount the tooltip so it reflects a potential new name.  It's a big janky, should probably use a react component instead.\n            $('*[data-toggle=\"tooltip\"]').tooltip('dispose');\n            $('*[data-toggle=\"tooltip\"]').tooltip();\n        });\n    }\n\n    componentWillUnmount() {\n        $('#indicator_modal_div').off('updated.tola.indicator.save');\n        $('#indicator_modal_div').off('deleted.tola.indicator.save');\n        $('#indicator_modal_div').off('created.tola.indicator.save');\n    }\n\n    saveLevel = (event) => {\n        event.preventDefault();\n        this.props.rootStore.levelStore.saveLevelToDB(\n            this.submitType,\n            this.props.level.id,\n            this.indicatorWasReordered,\n            {name: this.name,assumptions: this.assumptions,indicators: toJS(this.indicators)}\n        )\n\n    };\n\n    cancelEdit = () => {\n        if (this.props.rootStore.levelStore.levels.length == 1 && this.props.level.id == \"new\"){\n            this.clearData();\n        }\n        else{\n            this.props.rootStore.levelStore.cancelEdit(this.props.level.id);\n        }\n    };\n\n    clearData = () => {\n        this.name = \"\";\n        this.assumptions = \"\";\n    };\n\n    onFormChange = (event) => {\n        event.preventDefault();\n        this[event.target.name] = event.target.value;\n        // Add inline error message if name field is blanked out\n        if (!this.name) {\n            const target = $(`#level-name-${this.props.level.id}`);\n            target.addClass(\"is-invalid\");\n            /* # Translators: This is a validation message given to the user when the user-editable name field has been deleted or omitted. */\n            let feedbackText = `Please provide a name for this ${this.props.levelProps.tierName}`;\n            target.after(`<p id=name-feedback-${this.props.level.id} class=\"invalid-feedback\">${feedbackText}</p>`);\n        }\n        else{\n            $(`#level-name-${this.props.level.id}`).removeClass(\"is-invalid\");\n            $(`#name-feedback-${this.props.level.id}`).remove();\n        }\n        this.props.rootStore.uiStore.activeCardNeedsConfirm = this.dataHasChanged;\n    };\n\n    render(){\n        // Need to reference indicators so it reacts to changes.  Simply passing the observable this.indicators through\n        // to IndicatorList will result in a non-reactive Indicator list form fields.\n        const tempIndicators = toJS(this.indicators);\n\n        let indicatorSection = \"\";\n        if (this.props.level.id == \"new\"){\n            indicatorSection = <div className=\"form-group\">\n                    <button\n                    type=\"submit\"\n                    disabled={this.name.length > 0 ? false : true}\n                    className=\"btn btn-link btn-lg \"\n                    onClick={e => {this.updateSubmitType(\"saveAndEnableIndicators\")}}>\n                        { /* # Translators: This is button text that allows users to save their work and unlock the ability to add indicators */ }\n                        <i className=\"fas fa-plus-circle\"/>{gettext(`Save ${this.props.levelProps.tierName} and add indicators`)}\n                    </button>\n                </div>\n\n        }\n        else {\n            indicatorSection = <IndicatorList\n                        level={this.props.level}\n                        tierName={this.props.levelProps.tierName}\n                        indicators={this.indicators}\n                        disabled={!this.name || this.props.level.id == \"new\"}\n                        reorderDisabled={this.indicators.length < 2}\n                        changeFunc={this.changeIndicatorOrder}\n                        dragEndFunc={this.onDragEnd}/>\n        }\n\n\n\n        return (\n            <div className=\"level-card level-card--expanded\" id={`level-card-${this.props.level.id}`}>\n                <div>\n                    <LevelTitle\n                        tierName={this.props.levelProps.tierName}\n                        ontologyLabel={this.props.levelProps.ontologyLabel}\n                        classes=\"level-title--expanded\"\n                    />\n\n                </div>\n                <form className=\"level-card--expanded__form\" onSubmit={this.saveLevel}>\n                    <div className=\"form-group\">\n                        <textarea\n                            className=\"form-control\"\n                            id={`level-name-${this.props.level.id}`}\n                            name=\"name\"\n                            value={this.name || \"\"}\n                            autoComplete=\"off\"\n                            onChange={this.onFormChange}\n                        />\n                    </div>\n                    <div className=\"form-group\">\n                            <label htmlFor=\"assumptions\">Assumptions</label>\n                        <textarea\n                            className=\"form-control\"\n                            id=\"level-assumptions\"\n                            disabled={this.name? \"\" : \"disabled\"}\n                            name=\"assumptions\"\n                            autoComplete=\"off\"\n                            value={this.assumptions || \"\"}\n                            onChange={this.onFormChange}/>\n                    </div>\n                    {indicatorSection}\n                    <ButtonBar\n                        level={this.props.level}\n                        levelProps={this.props.levelProps}\n                        submitFunc={this.updateSubmitType}\n                        cancelFunc={this.cancelEdit}\n                        nameVal={this.name}\n                        tierCount={this.props.rootStore.levelStore.chosenTierSet.length}\n                    />\n                </form>\n            </div>\n\n        )\n    }\n}\n\n\n@inject('rootStore')\nclass ButtonBar extends React.Component {\n    render() {\n        let disabledText = this.props.nameVal ? \"\" : \"disabled\";\n\n        // Build the button text with the right sibling level name, then build the button.\n        let addAnotherButton = null;\n        if (this.props.level.parent != null && this.props.level.parent != \"root\") {\n            {/* # Translators: On a button, with a tiered set of objects, save current object and add another one in the same tier, e.g. \"Save and add another Outcome\" when the user is editing an Outcome */}\n            const buttonText = interpolate(gettext(\"Save and add another %s\"), [this.props.levelProps.tierName])\n            addAnotherButton = <LevelButton disabledText={disabledText} classes=\"btn-primary\" icon='plus-circle' text={buttonText} submitType=\"saveAndAddSibling\"  submitFunc={this.props.submitFunc} />\n        }\n\n        // Build the button text with the right child level name, then build the button.\n        let addAndLinkButton = null;\n        const tierCount = this.props.rootStore.levelStore.chosenTierSet.length;\n        if (this.props.level.level_depth < tierCount) {\n            {/* # Translators: On a button, with a tiered set of objects, save current object and add another one in the next lower tier, e.g. \"Save and add another Activity\" when the user is editing a Goal */}\n            const buttonText = interpolate(gettext(\"Save and link %s\"), [this.props.levelProps.childTierName])\n            addAndLinkButton = <LevelButton disabledText={disabledText} classes=\"btn btn-primary\" icon='stream' text={buttonText} submitType=\"saveAndAddChild\" submitFunc={this.props.submitFunc} />\n        }\n        return (\n            <div className=\"button-bar btn-row\">\n                <LevelButton disabledText={disabledText} classes=\"btn-primary\" text={gettext(\"Save and close\")} icon='save' submitType=\"saveOnly\" submitFunc={this.props.submitFunc} />\n                {addAnotherButton}\n                {addAndLinkButton}\n                <LevelButton classes=\"btn btn-reset\" text={gettext(\"Cancel\")} submitType=\"cancel\" submitFunc={this.props.cancelFunc} />\n            </div>\n        )\n\n    }\n}\n\nclass LevelButton extends React.Component {\n\n    render() {\n        const buttonType = this.props.submitType == \"cancel\" ? \"button\" : \"submit\";\n        return (\n            <button\n                disabled={this.props.disabledText}\n                type={buttonType}\n                className={this.props.classes + ' level-button btn btn-sm'}\n                onClick={() =>this.props.submitFunc(this.props.submitType)}>\n                {this.props.text}\n                {/*this.props.icon ?  <FontAwesomeIcon icon={this.props.icon} /> : ''*/}\n            </button>\n        )\n\n    }\n}\n\n@inject('rootStore')\nclass IndicatorList extends React.Component {\n\n    componentDidMount() {\n        // Enable popovers after update (they break otherwise)\n        $('*[data-toggle=\"popover\"]').popover({\n            html: true\n        });\n\n        $('*[data-toggle=\"tooltip\"]').tooltip()\n    }\n\n    componentDidUpdate() {\n\n        $('*[data-toggle=\"tooltip\"]').tooltip()\n    }\n\n\n    render() {\n\n        // Create the list of indicators and the dropdowns for setting the indicator order\n        let options = this.props.indicators.map( (entry, index) => {return {value: index+1, label: index+1}});\n\n        let indicatorMarkup = this.props.indicators.map ( (indicator) => {\n            // let options = this.props.indicators.map( (entry, index) => <option value={index+1}>{index+1}</option>);\n            const tipTemplate = '<div class=\"tooltip sortable-list__item__tooltip\" role=\"tooltip\"><div class=\"arrow\"></div><div class=\"tooltip-inner\"></div></div>';\n            const indicator_label =\n                <span data-toggle=\"tooltip\" data-delay={900} data-template={tipTemplate} title={indicator.name}>\n                    <span>{indicator.name.replace(/(.{55})..+/, \"$1...\")}</span>\n                </span>\n            return (\n                <React.Fragment>\n                    <SingleReactSelect\n                        update={(value) => this.props.changeFunc(indicator.id, value)}\n                        selectId={\"ind\"+indicator.id}\n                        labelClasses=\" \"\n                        formRowClasses=\"sortable-list__item__label\"\n                        selectClasses=\"sortable-list__item__select\"\n                        value={{value: indicator.level_order, label: indicator.level_order + 1}}\n                        label={indicator_label}\n                        options={options}\n                        disabled={this.props.disabled || this.props.reorderDisabled}\n                    />\n                    <div className=\"sortable-list__item__actions\">\n                        { /* # Translators: A label for a button that allows the user to modify the settings of an object */}\n                        <UpdateIndicatorButton readonly={this.props.disabled} label={gettext(\"Settings\")} indicatorId={indicator.id}/>\n                    </div>\n                </React.Fragment>\n            )\n        });\n\n        // Conditionally set the other elements that are only visible when there are indicators\n        let order = null;\n        let helpLink = null;\n        /* # Translators: Popover for help link, tell user how to diassociate an Indicator from the Level they are currently editing. */\n        const popOverContent=gettext('To remove an indicator: Click “Settings”, where you can reassign the indicator to a different level or delete it.');\n        if (this.props.indicators.length > 0) {\n            order = \"Order\";\n            helpLink =\n                <HelpPopover\n                    content={popOverContent}\n                    placement=\"bottom\"/>\n        }\n        return(\n            <div className={`level-card--indicator-links${this.props.disabled ? \" disabled\" : \"\"}`}>\n                <div className=\"indicator-links__header\">\n                    { /* # Translators: Title for a section that lists the Indicators associated with whatever this.props.tiername is. */}\n                    <h4>{gettext(`Indicators linked to this ${this.props.tierName}`)}</h4>\n                    <div>{helpLink}</div>\n                </div>\n                <div className=\"sortable-list-group\">\n                    { this.props.indicators.length > 0 ?\n                        <div className=\"sortable-list-header\">\n                            { /* TODO: this header is super janky. See _sortable-list.scss for future proofing with css subgrid */ }\n                            <div className=\"sortable-list-header__drag-handle\"><FontAwesomeIcon icon={faArrowsAlt} /></div>\n                            <div className=\"sortable-list-header__label\">\n                                {order}\n                            </div>\n                            <div className=\"sortable-list-header__actions\">\n                                <i className=\"fas fa-cog\"></i> { gettext(\"Settings\") }\n                            </div>\n                        </div>\n                    :\n                        null\n                    }\n                    <SortableContainer onSortEnd={this.props.dragEndFunc} useDragHandle lockAxis=\"y\" lockToContainerEdges>\n                        {indicatorMarkup.map((value, index) => (\n                            <SortableItem\n                                key={`item-${index}`}\n                                index={index}\n                                value={value}\n                                disabled={this.props.disabled || this.props.reorderDisabled} />\n                        ))}\n                    </SortableContainer>\n                    <div className=\"sortable-list-actions\">\n                        <AddIndicatorButton readonly={ !this.props.level.id || this.props.level.id == 'new' || this.props.disabled }\n                                            programId={ this.props.rootStore.levelStore.program_id }\n                                            levelId={ this.props.level.id }/>\n                    </div>\n                </div>\n            </div>\n        )\n    }\n}\n\nconst SortableItem = sortableElement(({value}) => <li className=\"sortable-list__item\"><DragHandle/>{value}</li>);\n\nconst SortableContainer = sortableContainer(({children}) => {\n    return <ul className=\"sortable-list\">{children}</ul>;\n});\n\nconst DragHandle = sortableHandle(() => <div className=\"sortable-list__item__drag-handle\"><FontAwesomeIcon icon={faArrowsAlt} /></div>);\n","import React from 'react';\nimport Select from 'react-select';\nimport ReactMultiSelectCheckboxes from 'react-multiselect-checkboxes';\nimport { uniqueId } from '../formUtils';\nimport { GROUP_BY_CHAIN, GROUP_BY_LEVEL } from '../constants';\n\n\n\nexport const SingleReactSelect = ( props ) => {\n    let selectId = uniqueId('react-select');\n    let labelClasses = props.labelClasses || \"col-form-label text-uppercase\";\n    let formRowClasses = props.formRowClasses || \"form-row mb-3\";\n    let selectClasses = props.selectClasses || \"tola-react-select\";\n    return (\n        <div className={ formRowClasses }>\n            <label\n                htmlFor={ selectId }\n                className={ labelClasses }>\n                    { props.label }\n            </label>\n            <Select\n                onChange={ props.update }\n                value={ props.value }\n                id={ selectId }\n                className={ selectClasses }\n                isDisabled={ props.disabled }\n                options={ props.options }\n            />\n        </div>\n    );\n}\n\nexport const DateSelect = ( props ) => {\n    let selectId = uniqueId('date-select');\n    let formattedOptions =\n        (props.options && props.options.length == 1 && props.options[0].value !== undefined) ?\n            <option value={ props.options[0].value }>{ props.options[0].label }</option> :\n            (props.options && props.options[0].options !== undefined) ?\n                props.options.map(\n                    (optgroup, index) => {\n                        return <optgroup label={ optgroup.label } key={ index }>\n                                    {optgroup.options.map(\n                                        option => (<option value={ option.value } key={ option.value }>\n                                                        { option.label }\n                                                   </option>)\n                                        )\n                                    }\n                                </optgroup>\n                        }) :\n                props.options.map(\n                    (option, index) => {\n                        return <option value={ option.value } key={ index }>{ option.label }</option>;\n                    }\n                );\n\n    return (\n        <div className=\"form-row mb-3\">\n            <label\n                htmlFor={ selectId }\n                className=\"col-form-label text-uppercase\">\n                    { props.label }\n            </label>\n            <select\n                className=\"form-control\"\n                id={ selectId }\n                value={ props.value }\n                onChange = { props.update }\n                disabled = { props.disabled }>\n                { formattedOptions }\n            </select>\n        </div>\n    );\n}\n\nexport const SingleSelect = ( props ) => {\n    let selectId = uniqueId('react-select');\n    let formGroupClass = props.formGroupClass || \"form-row mb-3\";\n    let labelClass = props.labelClass || \"col-form-label text-uppercase\";\n    let selectClass = props.selectClass || \"form-control\";\n    return (\n        <div className={ formGroupClass }>\n            <label\n                htmlFor={ selectId }\n                className={ labelClass }>\n                    { props.label }\n            </label>\n            <select\n                onChange={ props.update }\n                value={ props.value }\n                id={ selectId }\n                className={ selectClass }\n                disabled={ props.disabled }>\n                { props.options }\n            </select>\n        </div>\n    );\n}\n\n\n/**\n * styling element to replace OptGroup headings in react multiselect checkbox widgets - used for\n * MultiSelectCheckbox when optgroups are required\n */\nconst GroupHeading = (props) => {\n    if (props.children == '') {\n        return <div></div>;\n    } else {\n        return (\n            <React.Fragment>\n                <hr style={{ margin: '3px 0px 0px 0px' }} />\n                <div className=\"text-muted\"\n                     style={{ textTransform: 'uppercase',\n                              paddingLeft: '4px',\n                              marginBottom: '2px'}}>\n                    { props.children }\n                </div>\n            </React.Fragment>\n            );\n    }\n}\n\n\n/**\n * Styles ReactMultiSelectCheckbox to fit Tola styles\n */\nexport const MultiSelectCheckbox = ( props ) => {\n    const selectId = uniqueId('multiselect');\n    const multiSelectProps = (!props.options || props.options.length == 0) ?\n            {\n                getDropdownButtonLabel: () => gettext('None available'),\n                isDisabled: true,\n                menuIsOpen: false,\n                options: [],\n            } :\n            {\n                isMulti: true,\n                options: props.options,\n                getDropdownButtonLabel: (_ref) => {\n                    if (!_ref.value) {\n                        return gettext('None selected');\n                    }\n                    if (Array.isArray(_ref.value)) {\n                        if (_ref.value.length == 0) {\n                            return gettext('None selected');\n                        }\n                        if (_ref.value.length == 1) {\n                            return _ref.value[0].label;\n                        }\n                        return `${_ref.value.length}  ${gettext('selected')}`;\n                    }\n                    return _ref.value.label;\n                }\n            };\n    const baseStyles = {\n        dropdownButton: base => (!props.options || props.options.length == 0)\n                            ? { ...base, backgroundColor: '#E5E6E8', background: '' }\n                            : base,\n        option: (provided, state) => ({\n                ...provided,\n                padding: '1px 12px',\n                display: 'inline-block'\n            }),\n        container: (provided, state) => ({\n                ...provided,\n                backgroundColor: '#f5f5f5'\n            }),\n    };\n    const formatOptionLabel = (props) => {\n        return <div style={{ display: \"inline-block\" , float: \"right\", width: \"90%\"}}>{props.label}</div>;\n    };\n    return (\n        <div className=\"form-row mb-2 tola-react-multiselect-row\">\n            <label htmlFor={ selectId } className=\"col-form-label text-uppercase\">\n                { props.label }\n            </label>\n            <ReactMultiSelectCheckboxes\n                id={ selectId }\n                styles={ baseStyles }\n                formatOptionLabel = { formatOptionLabel }\n                components={{ GroupHeading }}\n                value={ props.value }\n                onChange={ props.update }\n                { ...multiSelectProps }\n            />\n        </div>\n    );\n}\n\nexport const GroupBySelect = ({ chainLabel, ...selectProps }) => {\n    let options = [\n        <option value={ GROUP_BY_CHAIN } key={1}>{ chainLabel }</option>,\n        <option value={ GROUP_BY_LEVEL } key={2}>{\n            /* # Translators: refers to grouping the report by the level of the indicator */\n            gettext('by Level')\n        }</option>\n    ];;\n    return <SingleSelect\n                label={\n                    /* # Translators: menu for selecting how rows are grouped in a report */\n                    gettext('Group indicators')\n                }\n                options={ options }\n                { ...selectProps }\n            />;\n}\n","import { observable, computed, action, toJS, runInAction, autorun } from \"mobx\";\nimport { api } from \"../../api.js\"\n\nexport class RootStore {\n    constructor (program_id, levels, indicators, levelTiers, tierTemplates, accessLevel) {\n        this.levelStore =  new LevelStore(program_id, levels, indicators, levelTiers, tierTemplates, accessLevel, this);\n        this.uiStore = new UIStore(this);\n    }\n}\n\nexport class LevelStore {\n    @observable levels = [];\n    @observable indicators = [];\n    @observable chosenTierSetKey = \"\";\n    @observable chosenTierSet = [];\n    program_id;\n    tierTemplates;\n    defaultTemplateKey = \"\";\n    customTierSetKey = \"\";\n    accessLevel = false;\n\n    constructor(program_id, levels, indicators, levelTiers, tierTemplates, accessLevel, rootStore) {\n        this.rootStore = rootStore;\n        this.levels = levels;\n        this.indicators = indicators;\n        this.tierTemplates = tierTemplates;\n        this.defaultTemplateKey = \"mc_standard\";\n        this.customTierSetKey = \"custom\";\n        this.program_id = program_id;\n        this.accessLevel = accessLevel;\n\n        // Set the stored tier set key and the values, if they exist.  Use the default if they don't.\n        if (levelTiers.length > 0) {\n            // deriveTemplateKey relies on chosenTierSet to be populated, so need to set it first.\n            this.chosenTierSet = levelTiers.map( t => t.name);\n            this.chosenTierSetKey = this.deriveTemplateKey(levelTiers);\n        }\n        else {\n            this.chosenTierSetKey = this.defaultTemplateKey;\n            this.chosenTierSet = this.tierTemplates[this.chosenTierSetKey]['tiers'];\n        }\n    }\n\n    @computed get sortedLevels () {\n        return this.levels.slice().sort((a, b) => {a.level_depth - b.level_depth || a.customsort - b.customsort})\n    }\n\n    @computed get levelProperties () {\n        let levelProperties = {};\n\n        for (let level of this.levels) {\n            let properties = {};\n            const childrenIds = this.getChildLevels(level.id).map( l => l.id);\n            const indicatorCount = this.indicators.filter( i => i.level == level.id);\n\n            properties['indicators'] = this.getLevelIndicators(level.id);\n            properties['descendantIndicatorIds'] = this.getDescendantIndicatorIds(childrenIds);\n            properties['ontologyLabel'] = this.buildOntology(level.id);\n            properties['tierName'] = this.chosenTierSet[level.level_depth-1];\n            properties['childTierName'] = null;\n            if (this.chosenTierSet.length > level.level_depth) {\n                properties['childTierName'] = this.chosenTierSet[level.level_depth];\n            }\n\n            properties['canDelete'] = childrenIds.length==0 && indicatorCount==0 && this.accessLevel=='high';\n            properties['canEdit'] = this.accessLevel == 'high';\n            levelProperties[level.id] = properties;\n        }\n\n        return levelProperties\n    }\n\n    @computed get chosenTierSetName () {\n        if (this.chosenTierSetKey == this.customTierSetKey){\n            return \"Custom\"\n        }\n        else {\n            return this.tierTemplates[this.chosenTierSetKey]['name']\n        }\n    };\n\n    // This monitors the number of indicators attached to the program and adds/removes the header link depending on\n    // whether there are indicators.  It relies on all indicators being passed up from the server each time\n    // the indicator list is refreshed.\n    monitorHeaderLink = autorun( reaction => {\n        let headerSpan = $(\"#rf_builder_header\");\n        let linkedFlag = headerSpan.children(\"a\").length > 0;\n        if (this.indicators.length > 0 && !linkedFlag ) {\n            const headerText = headerSpan.text();\n            headerSpan.html(`<a href=\"/program/${this.program_id}/\">${headerText}</a>`)\n        }\n        else if (this.indicators.length == 0 && linkedFlag) {\n            const headerText = $(\"#rf_builder_header > a\").text();\n            headerSpan.text(headerText);\n        }\n    // delay is needed to prevent undefined value from being used for program_id that isn't set yet on first load.\n    }, {delay: 50});\n\n    @action\n    changeTierSet(newTierSetKey) {\n        this.chosenTierSetKey = newTierSetKey;\n        this.chosenTierSet = this.tierTemplates[newTierSetKey]['tiers']\n    }\n\n    @action\n    cancelEdit = levelId => {\n        if (levelId == \"new\") {\n            const targetLevel = this.levels.find(l => l.id == levelId);\n\n            // First update any customsort values that were modified when this card was created\n            let siblingsToReorder = this.levels.filter(l => {\n                return l.customsort > targetLevel.customsort && l.parent == targetLevel.parent;\n            });\n            siblingsToReorder.forEach(sib => sib.customsort -= 1);\n\n            // Now remove the new card\n            this.levels.replace(this.levels.filter((element) => element.id != \"new\"));\n        }\n\n        this.fetchIndicatorsFromDB();\n        this.rootStore.uiStore.removeActiveCard();\n    };\n\n    @action\n    createNewLevelFromSibling = (siblingId) => {\n        // Copy sibling data for the new level and then clear some of it out\n        let sibling = toJS(this.levels.find( l => l.id == siblingId));\n        let newLevel = Object.assign({}, sibling);\n        newLevel.customsort += 1;\n        newLevel.id = \"new\";\n        newLevel.name = \"\";\n        newLevel.assumptions = \"\";\n\n        // bump the customsort field for siblings that come after the inserted Level\n        let siblingsToReorder = this.levels.filter( l => {\n            return sibling && l.customsort > sibling.customsort && l.parent == sibling.parent;\n        });\n        siblingsToReorder.forEach( sib => sib.customsort+=1);\n        // add new Level to the various Store components\n        this.rootStore.uiStore.activeCard = \"new\";\n        this.levels.push(newLevel);\n        setTimeout(\n            function(){$(\"#level-card-new\")[0].scrollIntoView({behavior:\"smooth\"})},\n            100\n        )\n    };\n\n    @action\n    createNewLevelFromParent = (parentId) => {\n        // Copy data for the new level and then clear some of it out\n        let parent = toJS(this.levels.find( l => l.id == parentId));\n        let newLevel = {\n            id:\"new\",\n            customsort: 1,\n            name: \"\",\n            assumptions: \"\",\n            parent: parentId,\n            level_depth: parent.level_depth + 1,\n            program: this.program_id\n        };\n\n        // bump the customsort field for siblings that come after the inserted Level\n        let siblingsToReorder = this.levels.filter( l => l.parent == parentId);\n\n        siblingsToReorder.forEach( sib => sib.customsort+=1);\n        // add new Level to the various Store components\n        this.levels.push(newLevel);\n        console.group('create new level from parent');\n        console.log('indicators in store')\n        this.levels.forEach (l => console.log(toJS(l)));\n        this.rootStore.uiStore.activeCard = \"new\";\n        this.rootStore.uiStore.hasVisibleChildren.push(newLevel.parent)\n        console.log('active card=', this.rootStore.uiStore.activeCard)\n        console.groupEnd()\n    };\n\n\n    @action\n    createFirstLevel = () => {\n        // Using \"root\" for parent id so the Django view can distinguish between top tier level and 2nd tier level\n        let newLevel = {\n            id: \"new\",\n            program: this.program_id,\n            name: \"\",\n            assumptions: \"\",\n            customsort: 1,\n            level_depth: 1,\n            parent: \"root\"\n        };\n        this.levels.push(newLevel);\n        this.rootStore.uiStore.activeCard = \"new\";\n    };\n\n    saveLevelTiersToDB = () => {\n        const tier_data = {program_id: this.program_id, tiers: this.chosenTierSet};\n        api.post(`/save_leveltiers/`, tier_data)\n            .then(response => {\n            })\n            .catch(error => console.log('error', error))\n    };\n\n    deleteLevelFromDB = (levelId) => {\n        const level_label = `${this.levelProperties[levelId]['tierName']} ${this.levelProperties[levelId]['ontologyLabel']}`;\n        api.delete(`/level/${levelId}`)\n            .then(response => {\n                this.levels.replace(response.data);\n                this.rootStore.uiStore.activeCard = null;\n                if (this.levels.length == 0){\n                    this.createFirstLevel()\n                }\n\n                // Translators: Notification to user that the deletion command that they issued was successful\n                success_notice({\n                    message_text: gettext(`${level_label} was deleted.`),\n                    addClass: 'program-page__rationale-form',\n                    stack: {\n                        dir1: 'up',\n                        dir2: 'right',\n                        firstpos1: 20,\n                        firstpos2: 20,\n                    }\n                })\n            })\n            .catch(error => console.log('error', error))\n    };\n\n\n    // TODO: better error handling for API\n    saveLevelToDB = (submitType, levelId, indicatorWasUpdated, formData) => {\n        // if indicators have been updated, call a separate save method and remove the data from object that will be sent with the level saving post request\n        if (indicatorWasUpdated) {\n            this.saveReorderedIndicatorsToDB(formData.indicators)\n        }\n        delete formData.indicators;\n\n        // Now process the save differently depending on if it's a new level or a pre-existing one.\n        let targetLevel = this.levels.find(level => level.id == levelId);\n        let levelToSave = Object.assign(toJS(targetLevel), formData);\n        if (levelId == \"new\") {\n            if (levelToSave.parent == \"root\") {\n                this.saveLevelTiersToDB()\n            }\n            delete levelToSave.id;\n\n            api.post(`/insert_new_level/`, levelToSave)\n                .then(response => {\n                    runInAction(() => {\n                        this.levels.replace(response.data['all_data'])\n                    });\n                    const newId = response.data[\"new_level\"][\"id\"];\n                    if (submitType == \"saveAndEnableIndicators\") {\n                        runInAction( () => {\n                           this.rootStore.uiStore.activeCard = newId;\n                        });\n                    }\n                    else if (submitType == \"saveAndAddSibling\"){\n                        // this.rootStore.uiStore.removeActiveCard();\n                        this.createNewLevelFromSibling(newId);\n\n                    }\n                    else if (submitType == \"saveAndAddChild\"){\n                        // this.rootStore.uiStore.removeActiveCard();\n                        this.createNewLevelFromParent(newId);\n\n                    }\n                })\n                .catch(error => console.log('error', error))\n\n        } else {\n            api.put(`/level/${levelId}/`, levelToSave)\n                .then(response => {\n                    runInAction( () => {\n                        Object.assign(targetLevel, response.data);\n                    });\n                    this.rootStore.uiStore.activeCard = null;\n                    if (submitType == \"saveAndAddSibling\"){\n                        this.createNewLevelFromSibling(levelId);\n                    }\n                    else if (submitType == \"saveAndAddChild\"){\n                        this.createNewLevelFromParent(levelId);\n                    }\n\n                })\n                .catch( error => {\n                    console.log(\"There was an error:\", error);\n                })\n        }\n\n        this.fetchIndicatorsFromDB();\n\n        this.rootStore.uiStore.activeCardNeedsConfirm = false;\n    };\n\n    saveReorderedIndicatorsToDB = indicators => {\n        api.post(\"/reorder_indicators/\", indicators)\n                .then(response => {\n                   this.fetchIndicatorsFromDB()\n                })\n                .catch( error => {\n                    console.log(\"There was an error:\", error);\n                })\n    };\n\n    @action\n    updateIndicatorNameInStore(indicatorId, newName) {\n        this.indicators.find( i => i.id == indicatorId).name = newName;\n    }\n\n    @action\n    deleteIndicatorFromStore = (indicatorId, levelId) => {\n        this.indicators = this.indicators.filter( i => i.id != indicatorId);\n        this.indicators\n            .filter( i => i.level == levelId)\n            .sort( (a, b) => a.level_order - b.level_order)\n            .forEach( (indicator, index) => indicator.level_order = index);\n    };\n\n    @action\n    addIndicatorToStore = (indicatorData) => {\n        this.indicators.push(indicatorData);\n    };\n\n    @action\n    moveIndicatorInStore = (indicatorId, newLevelId) => {\n        let target = this.indicators.find( i => i.id == indicatorId);\n        target.level = newLevelId;\n        target.level_order = this.indicators.filter( i => i.level == newLevelId).length -1;\n    };\n\n    fetchIndicatorsFromDB = (indicatorId=null) => {\n        const indicatorQParam = indicatorId ? `?indicatorId=${indicatorId}` : \"\";\n        api.get(`/indicator_list/${this.program_id}/${indicatorQParam}`)\n            .then((response) => runInAction(() => {\n                this.indicators = response.data;\n            }))\n            .catch((error) => console.log('There was an error:', error));\n    };\n\n\n    deriveTemplateKey = () => {\n        // Check each tier set in the templates to see if the tier order and content are exactly the same\n        // If they are, return the template key\n        const levelTierStr = JSON.stringify(toJS(this.chosenTierSet));\n        for (let templateKey in this.tierTemplates){\n            // not an eligable template if the key is inherited or if the lengths of the tier sets don't match.\n            if (!this.tierTemplates.hasOwnProperty(templateKey) ||\n                this.chosenTierSet.length != this.tierTemplates[templateKey]['tiers'].length) {\n                continue;\n            }\n            const templateValuesStr = JSON.stringify(this.tierTemplates[templateKey]['tiers']);\n            if (levelTierStr == templateValuesStr) {\n                return templateKey;\n            }\n        }\n\n        // If this has been reached, the db has stored tiers but they're not a match to a template\n        return \"custom\";\n    };\n\n\n    buildOntology = (levelId, ontologyArray = []) => {\n        let level = toJS(this.levels.find( l => l.id == levelId));\n        /*  If there is no parent (saved top tier level) or the parent is \"root\" (unsaved top tier level)\n            then we should return with adding to the ontology because there is no ontology entry for the top tier\n         */\n        if (level.parent && level.parent != \"root\") {\n            ontologyArray.unshift(level.customsort);\n            return this.buildOntology(level.parent, ontologyArray);\n        }\n        else {\n            return ontologyArray.join(\".\");\n        }\n    };\n\n    getChildLevels = levelId => this.levels.filter( l => l.parent == levelId);\n\n    getLevelIndicators = levelId => this.indicators.filter( i => i.level == levelId);\n\n    getDescendantIndicatorIds = (childLevelIds) => {\n        const childLevels = this.levels.filter( l => childLevelIds.includes(l.id));\n        let newIndicatorIds = [];\n        childLevels.forEach( childLevel => {\n            newIndicatorIds = newIndicatorIds.concat(this.indicators.filter( i => i.level == childLevel.id).map( i => i.id));\n            let grandChildIds = this.levels.filter( l => l.parent == childLevel.id).map( l => l.id);\n            newIndicatorIds = newIndicatorIds.concat(this.getDescendantIndicatorIds(grandChildIds, newIndicatorIds));\n        });\n        return newIndicatorIds\n    }\n\n}\n\n\nexport class UIStore {\n\n    @observable activeCard;\n    @observable hasVisibleChildren = [];\n    activeCardNeedsConfirm = \"\";\n\n    constructor (rootStore) {\n        this.rootStore = rootStore;\n        this.hasVisibleChildren = this.rootStore.levelStore.levels.map(l => l.id)\n        this.activeCardNeedsConfirm = false;\n        this.activeCard = null;\n    }\n\n    @computed get tierLockStatus () {\n        // The leveltier picker should be disabled if there is at least one saved level in the DB.\n        let notNewLevels = this.rootStore.levelStore.levels.filter( l => l.id != \"new\");\n        if  (notNewLevels.length > 0) {\n            return \"locked\"\n        }\n        // The apply button should not be visible if there is only one level visible (i.e. saved to the db or not)\n        else if (this.rootStore.levelStore.levels.length == 1){\n            return \"primed\"\n        }\n\n        return null;\n    }\n    // TODO: Make sure old editing data is not preserved when an edit is cancelled\n    @action\n    editCard = (levelId) => {\n        const cancelledLevelId = this.activeCard;\n        if (this.activeCardNeedsConfirm) {\n            console.log('in edit, needed confirm, levelId=', levelId, )\n            $(`#level-card-${this.activeCard}`)[0].scrollIntoView({behavior:\"smooth\"});\n            const oldTierName = this.rootStore.levelStore.levelProperties[this.activeCard].tierName;\n            $(\".edit-button\").prop(\"disabled\", true);\n            create_no_rationale_changeset_notice({\n                /* # Translators:  This is a confirmation prompt that is triggered by clicking on a cancel button.  */\n                message_text: gettext(\"Are you sure you want to continue?\"),\n                /* # Translators:  This is a warning provided to the user when they try to cancel the editing of something they have already modified.  */\n                preamble: gettext(`Changes to this ${oldTierName} will not be saved`),\n                type: \"notice\",\n                on_submit: () => this.onLeaveConfirm(levelId, cancelledLevelId),\n                on_cancel: this.onLeaveCancel,\n            })\n        }\n        else {\n            this.activeCard = levelId;\n            this.rootStore.levelStore.levels.replace(this.rootStore.levelStore.levels.filter( l => l.id != \"new\"))\n        }\n    };\n\n    @action\n    onLeaveConfirm = (levelId, cancelledLevelId) => {\n        this.rootStore.levelStore.cancelEdit(cancelledLevelId);\n        this.activeCardNeedsConfirm = false;\n        $(\".edit-button\").prop(\"disabled\", false);\n        this.activeCard = levelId;\n        // Need to use set timeout to ensure that scrolling loses the race with components reacting to the new position of the open card.\n        setTimeout(\n            function(){$(`#level-card-${levelId}`)[0].scrollIntoView({behavior:\"smooth\"})},\n            100\n        );\n    };\n\n    onLeaveCancel = () => {\n        $(\".edit-button\").prop(\"disabled\", false);\n    };\n\n    @action\n    removeActiveCard = () => {\n        this.activeCard = null;\n        this.rootStore.uiStore.activeCardNeedsConfirm = false;\n    };\n\n    @action\n    updateVisibleChildren = (levelId, forceHide=false, forceShow=false) => {\n        // forceHide is to ensure that descendant levels are also made hidden, even if they are not actually visible.\n        if (this.hasVisibleChildren.indexOf(levelId) >= 0 || forceHide) {\n            this.hasVisibleChildren = this.hasVisibleChildren.filter( level_id => level_id != levelId );\n            const childLevels = this.rootStore.levelStore.levels.filter( l => l.parent == levelId);\n            childLevels.forEach( l => this.updateVisibleChildren(l.id, true))\n        }\n        else {\n            this.hasVisibleChildren.push(levelId);\n        }\n    }\n}\n","/*\n * ID generating code &c. for form inputs\n */\n\nlet lastId = 0;\n\nexport function uniqueId (prefix='id') {\n    lastId++;\n    return `${prefix}${lastId}`;\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from \"mobx-react\"\nimport eventBus from '../../eventbus';\nimport createRouter from 'router5';\nimport browserPlugin from 'router5-plugin-browser';\n\nimport {LevelListPanel} from './components/level_list';\nimport {LevelTierPicker} from './components/leveltier_picker';\nimport {RootStore} from './models';\n\n/*\n * Model/Store setup\n */\nconst {program_id, levels, indicators, levelTiers, tierTemplates, accessLevel} = jsContext;\nconst rootStore = new RootStore(program_id, levels, indicators, levelTiers, tierTemplates, accessLevel);\n\n/*\n * React components on page\n */\n\nReactDOM.render(\n    <Provider rootStore={rootStore}>\n        <React.Fragment>\n            <LevelTierPicker />\n            <LevelListPanel />\n        </React.Fragment>\n    </Provider>,\n    document.querySelector('#level-builder-react-component'));\n\n\n","import axios from 'axios';\n\nexport const api = axios.create({\n    withCredentials: true,\n    baseURL: '/api/',\n    headers: {\n        \"X-CSRFToken\": document.cookie.replace(/(?:(?:^|.*;\\s*)csrftoken\\s*\\=\\s*([^;]*).*$)|^.*$/, \"$1\")\n    }\n});\n","import React from 'react';\nimport { observer } from 'mobx-react';\n\nexport const AddIndicatorButton = observer(({ readonly, ...params }) => {\n    return (\n            <button\n                type=\"button\"\n                disabled={readonly}\n                className=\"btn btn-link btn-add\"\n                onClick={e => {openCreateIndicatorFormModal(params)}}>\n                <i className=\"fas fa-plus-circle\"/> {gettext(\"Add indicator\")}\n            </button>\n    );\n});\n\n\nexport const UpdateIndicatorButton = observer(({ readonly, label=null, ...params }) => {\n    return (\n            <button\n                type=\"button\"\n                disabled={readonly}\n                className=\"btn btn-link\"\n                onClick={e => {openUpdateIndicatorFormModal(params)}}>\n                <i className=\"fas fa-cog\"/>{label}\n            </button>\n    );\n});\n","// A global instance of an event bus\nimport nanobus from 'nanobus';\n\nconst globalEventBus = nanobus();\n\nexport default globalEventBus;\n","import React from 'react';\nimport classNames from 'classnames';\nimport { observer, inject } from \"mobx-react\"\nimport { toJS } from 'mobx';\nimport { library } from '@fortawesome/fontawesome-svg-core'\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { faCaretDown, faCaretRight } from '@fortawesome/free-solid-svg-icons'\nimport Select from 'react-select';\nimport {LevelCardCollapsed, LevelCardExpanded} from \"./level_cards\";\n\nlibrary.add(faCaretDown, faCaretRight);\n\n@inject('rootStore')\n@observer\nclass LevelList extends React.Component {\n\n    render() {\n        let renderList = [];\n        if (this.props.renderList == 'initial') {\n            renderList = this.props.rootStore.levelStore.sortedLevels\n                .filter(level => ['root', null].indexOf(level.parent) != -1)\n        }\n\n        else{\n            renderList = this.props.renderList.sort((a, b) => a.customsort - b.customsort);\n        }\n\n        return renderList.map((elem) => {\n            console.group('in level list');\n            console.log('active card', this.props.rootStore.uiStore.activeCard);\n            console.log('element', toJS(elem));\n            console.groupEnd();\n            let card = '';\n            if (this.props.rootStore.uiStore.activeCard == elem.id) {\n                card =\n                    <LevelCardExpanded\n                        level={elem}\n                        levelProps={this.props.rootStore.levelStore.levelProperties[elem.id]}/>\n            }\n            else {\n                card =\n                    <LevelCardCollapsed\n                        level={elem}\n                        levelProps={this.props.rootStore.levelStore.levelProperties[elem.id]}/>\n            }\n\n            let children = this.props.rootStore.levelStore.sortedLevels.filter(level => level.parent == elem.id);\n            let childLevels = null;\n            if (children.length > 0){\n                childLevels =  <LevelList\n                    rootStore={this.props.rootStore}\n                    renderList={children}/>\n            }\n\n            return (\n                <div key={elem.id} className=\"leveltier--new\">\n                    {card}\n                    {childLevels}\n                </div>\n            )\n    })}\n}\n\n@inject('rootStore')\n@observer\nexport class LevelListPanel  extends React.Component {\n\n    render() {\n        if (this.props.rootStore.levelStore.levels.length == 0) {\n            return (\n                <div className=\"level-list-panel\">\n                    <div className=\"level-list-panel__dingbat\">\n                        <i className=\"fas fa-sitemap\"></i>\n                    </div>\n                    <div className=\"level-list-panel__text text-large\">\n                        <strong className=\"text-danger\">Choose your results framework template carefully!</strong> Once you begin building your framework, it will not be possible to change templates without first deleting all saved levels.\n                    </div>\n                </div>\n            )\n        }\n        else {\n            return (\n                <div id=\"level-list\" style={{flexGrow: \"2\"}}><LevelList renderList='initial'/></div>\n            )\n        }\n    }\n}\n\n","\n/**\n * IPTT Constants:\n */\nconst BLANK_LABEL = '---------';\nconst BLANK_OPTION = {\n    value: null,\n    label: BLANK_LABEL\n};\nconst BLANK_TABLE_CELL = '—';\n\n\nconst TVA = 1;\nconst TIMEPERIODS = 2;\n\nconst TIME_AWARE_FREQUENCIES = [3, 4, 5, 6, 7];\n\nexport { BLANK_OPTION, BLANK_LABEL, BLANK_TABLE_CELL, TVA, TIMEPERIODS, TIME_AWARE_FREQUENCIES };\n\nconst GROUP_BY_CHAIN = 1;\nconst GROUP_BY_LEVEL = 2;\n\nexport { GROUP_BY_CHAIN, GROUP_BY_LEVEL };\n\nconst _gettext = (typeof gettext !== 'undefined') ?  gettext : (s) => s;\n\nfunction getPeriodLabels() {\n    return {\n        targetperiodLabels: {\n            1: _gettext(\"Life of Program (LoP) only\"),\n            3: _gettext(\"Annual\"),\n            2: _gettext(\"Midline and endline\"),\n            5: _gettext(\"Tri-annual\"),\n            4: _gettext(\"Semi-annual\"),\n            7: _gettext(\"Monthly\"),\n            6: _gettext(\"Quarterly\")\n        },\n        timeperiodLabels: {\n            3: _gettext(\"Years\"),\n            5: _gettext(\"Tri-annual periods\"),\n            4: _gettext(\"Semi-annual periods\"),\n            7: _gettext(\"Months\"),\n            6: _gettext(\"Quarters\")\n        }\n    };\n}\n\nexport {getPeriodLabels};\n\nexport const STATUS_CODES = {\n    NO_INDICATOR_IN_UPDATE: 1\n};"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AAEA;AAIA;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;AACA;;;;;;AACA;AACA;AACA;AACA;AADA;AAGA;;;AAEA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AALA;AAMA;AAAA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AALA;AAMA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AACA;AAJA;AASA;;;;AA3DA;AACA;AA6DA;;;;;;;;;;;;;AAEA;AACA;AACA;AAAA;AACA;;;;AALA;AACA;AASA;;;;;;;;;;;;;AAEA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAFA;AAMA;AACA;AACA;AAEA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAQA;AAAA;AAOA;;;;AApCA;AAuCA;AAEA;AACA;AAAA;AAAA;AAIA;AALA;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjIA;AACA;AACA;AACA;;;;;AACA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AAHA;AAIA;AACA;;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AAOA;AAAA;AAEA;;;;AAlBA;AACA;AADA;AAsBA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AACA;AAAA;AACA;AAKA;AACA;AAAA;AACA;AACA;AACA;AAHA;AAKA;AACA;AA/BA;AAiCA;AACA;AACA;AAnCA;AAAA;AACA;AADA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AAAA;AAGA;AACA;AAAA;AAOA;AAXA;AACA;AADA;AAAA;AAgBA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AAAA;AAAA;AACA;AADA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAHA;AAKA;AACA;AAVA;AAYA;AACA;AACA;AAdA;AAuBA;AACA;AAAA;AAAA;AACA;AACA;AACA;AA3BA;AAAA;AACA;AADA;AAAA;AAAA;AAgBA;AACA;AACA;AADA;AAGA;AApBA;AAAA;AAAA;AA4BA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AACA;AADA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAFA;AAIA;AAAA;AAEA;AACA;AACA;AAHA;AAQA;AAAA;AACA;AAAA;AAGA;AACA;AAFA;AAGA;AAAA;AAIA;AAAA;AAAA;AACA;AAAA;AAIA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAeA;AA7HA;AACA;AADA;AAAA;AAmIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AAFA;AA+CA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AArDA;AAwDA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAjEA;AAuEA;AACA;AACA;AAzEA;AAkJA;AACA;AAAA;AAIA;AAAA;AAAA;AAAA;AAGA;AACA;AA3JA;AA6JA;AACA;AACA;AAEA;AACA;AACA;AACA;AApKA;AAsKA;AACA;AACA;AACA;AAzKA;AA2KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAzLA;AACA;AAGA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AA1BA;AA6BA;AACA;AACA;AAHA;AAKA;AA5CA;AA6CA;AACA;AA/CA;AAAA;AAAA;AA4EA;AACA;AACA;AACA;AADA;AAGA;AAjFA;AAAA;AAAA;AAmFA;AACA;AAAA;AACA;AACA;AADA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAJA;AACA;AAKA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1IA;AAAA;AAAA;AA6IA;AACA;AACA;AACA;AAhJA;AAAA;AAAA;AA6LA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAMA;AAAA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAQA;AACA;AAGA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AAHA;AAOA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AASA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAWA;AACA;AACA;AACA;AACA;AACA;AANA;AAYA;AA1QA;AACA;AADA;AAAA;AA+QA;;;;;;;;;;;;;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAIA;;;;AA7BA;AACA;AA+BA;;;;;;;;;;;;;AAEA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAUA;;;;AAfA;AACA;AAkBA;;;;;;;;;;;;;AAEA;AACA;AACA;AACA;AADA;AAIA;AACA;;;AAEA;AAEA;AACA;;;AAGA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAGA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AATA;AAWA;AAAA;AAEA;AAAA;AAAA;AAAA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAFA;AAGA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAKA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;AACA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAJA;AADA;AAQA;AAAA;AACA;AACA;AACA;AAFA;AAOA;;;;AArGA;AAwGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnlBA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAFA;AAMA;AACA;AACA;AACA;AACA;AACA;AANA;AAUA;AAEA;AACA;AACA;AAEA;AAAA;AAIA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAMA;AAGA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AAAA;AAEA;AACA;AAFA;AAMA;AACA;AACA;AACA;AACA;AALA;AAUA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAFA;AAMA;AACA;AACA;AACA;AACA;AALA;AAUA;AAGA;;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAFA;AADA;AAQA;AACA;AAGA;;;;;AAGA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAjBA;AAmBA;AACA;AAAA;AACA;AAAA;AADA;AAAA;AAGA;AAAA;AAEA;AACA;AAHA;AAAA;AAKA;AAAA;AAEA;AAFA;AAAA;AATA;AACA;AAaA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AANA;AAWA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AALA;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5MA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAGA;AAAA;AAAA;AAWA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AA5EA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AA6KA;AAAA;AAAA;AAAA;AACA;AAGA;AAAA;AACA;AACA;AAnLA;AAqLA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAHA;AAUA;AACA;AAAA;AACA;AACA;AA5MA;AAgNA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/QA;AAiRA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAzRA;AACA;AADA;AACA;AADA;AACA;AADA;AAoTA;AACA;AACA;AACA;AACA;AACA;AAFA;AAGA;AAAA;AACA;AACA;AA5TA;AA+TA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjVA;AAmVA;AACA;AAAA;AAAA;AACA;;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAhWA;AAiWA;AAAA;AAAA;AAAA;AACA;AAlWA;AAmWA;AAAA;AAAA;AAAA;AACA;AApWA;AAsWA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AA9WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAC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","sourceRoot":""}